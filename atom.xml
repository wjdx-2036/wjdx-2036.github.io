<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhisheng的博客</title>
  
  <subtitle>坑要一个个填，路要一步步走！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-09T05:07:28.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zhisheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot 2.0 迁移指南</title>
    <link href="http://yoursite.com/2018/03/06/SpringBoot2-Migration-Guide/"/>
    <id>http://yoursite.com/2018/03/06/SpringBoot2-Migration-Guide/</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-03-09T05:07:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fp3h0820m2j31hc0zkwxr.jpg" alt=""></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>希望本文档将帮助您把应用程序迁移到 Spring Boot 2.0。</p><a id="more"></a><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/</a></p><h3 id="在你开始之前"><a href="#在你开始之前" class="headerlink" title="在你开始之前"></a>在你开始之前</h3><p>首先，<strong>Spring Boot 2.0 需要 Java 8 或更高版本</strong>。不再支持 Java 6 和 7 了。</p><p>在 Spring Boot 2.0 中，许多配置属性被重新命名/删除，开发人员需要更新<code>application.properties</code>/ <code>application.yml</code>相应的配置。为了帮助你解决这一问题，Spring Boot 发布了一个新<code>spring-boot-properties-migrator</code>模块。一旦作为该模块作为依赖被添加到你的项目中，它不仅会分析应用程序的环境，而且还会在启动时打印诊断信息，而且还会在运行时为您暂时迁移属性。在您的应用程序迁移期间，这个模块是必备的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-properties-migrator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：完成迁移后，请确保从项目的依赖关系中删除此模块。</p><h3 id="构建您的-Spring-Boot-应用程序"><a href="#构建您的-Spring-Boot-应用程序" class="headerlink" title="构建您的 Spring Boot 应用程序"></a>构建您的 Spring Boot 应用程序</h3><h4 id="Spring-Boot-Maven-插件"><a href="#Spring-Boot-Maven-插件" class="headerlink" title="Spring Boot Maven 插件"></a>Spring Boot Maven 插件</h4><p>为了保持了一致性，并且避免与其他插件发生冲突，现在暴露的插件配置属性都以一个<code>spring-boot</code>前缀开始。</p><p>例如，以下命令<code>prod</code>使用命令行启用配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:run -Dspring-boot.run.profiles=prod</span><br></pre></td></tr></table></figure><h5 id="Surefire-默认值"><a href="#Surefire-默认值" class="headerlink" title="Surefire 默认值"></a>Surefire 默认值</h5><p>以前的 <code>include/exclude</code> 模式已与最新的 Surefire 默认设置保持一致。如果依赖于此插件，需要相应地更新插件配置。之前对应的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*Tests.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*Test.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/Abstract*.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>PS: 如果您使用 JUnit 5，则应将 Surefire 降级到 <code>2.19.1</code>。该<code>**/*Tests.java</code>版本不包含此模式，因此如果您依赖该模式，请确保将其添加到您的配置中。</p><h4 id="Spring-Boot-Gradle-插件"><a href="#Spring-Boot-Gradle-插件" class="headerlink" title="Spring Boot Gradle 插件"></a>Spring Boot Gradle 插件</h4><p>Spring Boot 的 Gradle 插件在很大程度上已被重写，以实现许多重大改进。您可以在其<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/gradle-plugin/reference" target="_blank" rel="noopener">参考文献</a>和<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/gradle-plugin/api" target="_blank" rel="noopener">API</a>文档中阅读关于插件功能的更多信息。</p><h5 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h5><p>Spring Boot 的 Gradle 插件不再自动应用依赖管理插件。相反，Spring Boot 的插件现在可以通过导入正确版本的spring-boot-dependencies BOM 来应用依赖管理插件。这使您可以更好地控制配置依赖性管理的方式和时间。</p><p>对于大多数使用依赖管理插件的应用程序来说就足够了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;org.springframework.boot&apos;</span><br><span class="line">apply plugin: &apos;io.spring.dependency-management&apos; // &lt;-- add this to your build.gradle</span><br></pre></td></tr></table></figure><p>注意：依赖管理插件仍然是 spring-boot-gradle-plugin 的传递依赖项，所以不需要在 buildscript 配置中将其列为类路径依赖项。</p><h5 id="建立可执行的-Jars-和-Wars"><a href="#建立可执行的-Jars-和-Wars" class="headerlink" title="建立可执行的 Jars 和 Wars"></a>建立可执行的 Jars 和 Wars</h5><p>该<code>bootRepackage</code>任务已被替换<code>bootJar</code>，并<code>bootWar</code>分别建立可执行的 Jars 和 Wars 的任务。<code>jar</code>和<code>war</code>任务不再参与。</p><h5 id="配置更新"><a href="#配置更新" class="headerlink" title="配置更新"></a>配置更新</h5><p><code>BootRun</code>，<code>BootJar</code>和<code>BootWar</code>任务现在都使用<code>mainClassName</code>的属性来配置主类的名称。这使得三个特定于引导的任务相互一致，并将其与 Gradle 自己的应用程序插件进行对齐。</p><h3 id="Spring-Boot-特性"><a href="#Spring-Boot-特性" class="headerlink" title="Spring Boot 特性"></a>Spring Boot 特性</h3><h4 id="默认代理策略"><a href="#默认代理策略" class="headerlink" title="默认代理策略"></a>默认代理策略</h4><p>Spring Boot 默认使用 CGLIB 代理，包括 AOP 支持。如果你需要基于代理的代理，你需要设置<code>spring.aop.proxy-target-class</code>为<code>false</code>。</p><h4 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h4><h5 id="Web-环境"><a href="#Web-环境" class="headerlink" title="Web 环境"></a>Web 环境</h5><p>Spring Boot 应用程序现在可以在更多模式下运行，因此<code>spring.main.web-environment</code>现在不推荐使用属性来支持<code>spring.main.web-application-type</code>更多的控制。</p><p>如果您想确保应用程序不启动 Web 服务器，则必须将该属性更改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.main.web-application-type=none</span><br></pre></td></tr></table></figure><p>注意：还有一个<code>setWebApplicationType</code>上<code>SpringApplication</code>，如果你想这样做编程。</p><h5 id="Spring-Boot-应用程序事件更改"><a href="#Spring-Boot-应用程序事件更改" class="headerlink" title="Spring Boot 应用程序事件更改"></a>Spring Boot 应用程序事件更改</h5><p>我们已经添加了一个新事件<code>ApplicationStartedEvent</code>。 <code>ApplicationStartedEvent</code>在上下文刷新之后但在任何应用程序和命令行参数被调用之前发送。 <code>ApplicationReadyEvent</code>在任何应用程序和命令行参数被调用后发送。它表示应用程序已准备好为请求提供服务。</p><p>请参阅<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-application-events-and-listeners" target="_blank" rel="noopener">更新的参考文档</a>。</p><h5 id="Banner"><a href="#Banner" class="headerlink" title="Banner"></a>Banner</h5><p>在我们限制 Spring Boot 使用的根名称空间的数量的过程中，与标志相关的属性已被重定位到<code>spring.banner</code>。</p><h4 id="外部化配置"><a href="#外部化配置" class="headerlink" title="外部化配置"></a>外部化配置</h4><h5 id="轻松的绑定"><a href="#轻松的绑定" class="headerlink" title="轻松的绑定"></a>轻松的绑定</h5><p>有关宽松绑定的规则已经收紧。我们假设一个现有的<code>acme.my-project.my-name</code>属性：</p><ol><li>所有前缀必须是 kebab格式（小写，连字符分隔）<code>acme.myProject</code>或<code>acme.my_project</code>无效 - 您必须<code>acme.my-project</code>在此处使用。</li><li>属性名称可以使用 kebab-case（<code>my-name</code>），camel-case（<code>myName</code>）或 snake-case（<code>my_name</code>）。</li><li>环境属性（来自操作系统环境变量）<em>必须使用</em>通常的大写下划线格式，下划线<em>只能</em>用于分隔键的各个部分<code>ACME_MYPROJECT_MYNAME</code>。</li></ol><p>这种新的放松绑定具有以下几个优点：</p><ul><li>无需担心密钥的结构<code>@ConditionalOnProperty</code>：只要密钥是以规范格式定义的，支持的松散变体就可以透明地工作。如果您正在使用该<code>prefix</code>属性，则现在只需使用<code>name</code>或<code>value</code>属性即可放置完整密钥。</li><li><code>RelaxedPropertyResolver</code>不再可以<code>Environment</code>自动处理：<code>env.getProperty(&quot;com.foo.my-bar&quot;)</code>将找到一个<code>com.foo.myBar</code>属性。</li></ul><p>该<code>org.springframework.boot.bind</code>软件包不再可用，并被<a href="https://github.com/spring-projects/spring-boot/wiki/Relaxed-Binding-2.0" target="_blank" rel="noopener">新的宽松绑定规则</a>所取代。特别是，<code>RelaxedDataBinder</code>朋友已被新的<code>Binder</code>API 取代。以下样品<code>MyProperties</code>从<code>app.acme</code>前缀中进行绑定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyProperties target = Binder.get(environment)</span><br><span class="line">.bind(<span class="string">"app.acme"</span>, MyProperties.class)</span><br><span class="line">.orElse(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>由于现在内置了轻松绑定，因此只要使用其中一种支持的格式，就可以请求任何属性而不必关心案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FlagType flagType = Binder.get(environment)</span><br><span class="line">.bind(<span class="string">"acme.app.my-flag"</span>, FlagType.class)</span><br><span class="line">.orElse(FlagType.DEFAULT);</span><br></pre></td></tr></table></figure><h5 id="ConfigurationProperties-验证"><a href="#ConfigurationProperties-验证" class="headerlink" title="@ConfigurationProperties 验证"></a><code>@ConfigurationProperties</code> 验证</h5><p>如果您想打开验证，现在必须为您的<code>@ConfigurationProperties</code>对象添加注释<code>@Validated</code>。</p><h5 id="配置位置"><a href="#配置位置" class="headerlink" title="配置位置"></a>配置位置</h5><p><code>spring.config.location</code>配置的行为已被修复; 它先前将一个位置添加到默认位置列表中，现在它将替换默认位置。如果你依靠之前处理的方式，现在应该使用它<code>spring.config.additional-location</code>。</p><h4 id="开发-Web-应用程序"><a href="#开发-Web-应用程序" class="headerlink" title="开发 Web 应用程序"></a>开发 Web 应用程序</h4><h5 id="嵌入式容器包装结构"><a href="#嵌入式容器包装结构" class="headerlink" title="嵌入式容器包装结构"></a>嵌入式容器包装结构</h5><p>为了支持反应性用例，嵌入式容器包结构已经被非常广泛地重构。 <code>EmbeddedServletContainer</code>已被重新命名为，<code>WebServer</code>并且该<code>org.springframework.boot.context.embedded</code>包已被重新定位到<code>org.springframework.boot.web.embedded</code>。例如，如果您使用<code>TomcatEmbeddedServletContainerFactory</code>回调接口定制嵌入式Tomcat容器，则应该使用<code>TomcatServletWebServerFactory</code>。</p><h5 id="特定于-Servlet-的服务器属性"><a href="#特定于-Servlet-的服务器属性" class="headerlink" title="特定于 Servlet 的服务器属性"></a>特定于 Servlet 的服务器属性</h5><p>许多<code>server.*</code> 属性 ( Servlet 特有的) 已经转移到<code>server.servlet</code>：</p><table><thead><tr><th style="text-align:center">旧的属性</th><th style="text-align:center">新的属性</th></tr></thead><tbody><tr><td style="text-align:center">server.context-parameters.*</td><td style="text-align:center">server.servlet.context-parameters.*</td></tr><tr><td style="text-align:center">server.context-path</td><td style="text-align:center">server.servlet.context-path</td></tr><tr><td style="text-align:center">server.jsp.class-name</td><td style="text-align:center">server.servlet.jsp.class-name</td></tr><tr><td style="text-align:center">server.jsp.init-parameters.*</td><td style="text-align:center">server.servlet.jsp.init-parameters.*</td></tr><tr><td style="text-align:center">server.jsp.registered</td><td style="text-align:center">server.servlet.jsp.registered</td></tr><tr><td style="text-align:center">server.servlet-path</td><td style="text-align:center">server.servlet.path</td></tr></tbody></table><h5 id="Web-Starter-作为传递依赖"><a href="#Web-Starter-作为传递依赖" class="headerlink" title="Web Starter 作为传递依赖"></a>Web Starter 作为传递依赖</h5><p>以前有几个 Spring Boot starter 是依赖于 Spring MVC 而传递的<code>spring-boot-starter-web</code>。借助 Spring WebFlux的新支持<code>spring-boot-starter-mustache</code>，<code>spring-boot-starter-freemarker</code>并<code>spring-boot-starter-thymeleaf</code>不再依赖它。开发者有责任选择和添加<code>spring-boot-starter-web</code>或<code>spring-boot-starter-webflux</code>。</p><h5 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h5><p>Mustache 模板的默认文件扩展名是<code>.html</code>，它现在<code>.mustache</code>与官方规范和大多数IDE插件一致。您可以通过更改<code>spring.mustache.suffix</code>配置键来覆盖此新的默认值。</p><h5 id="Jackson-JSON-支持"><a href="#Jackson-JSON-支持" class="headerlink" title="Jackson / JSON 支持"></a>Jackson / JSON 支持</h5><p>在 2.0 中，我们改变了 Jackson 配置默认值，将 JSR-310 日期写为 ISO-8601 字符串。如果你想回到以前的行为，你可以添加<code>spring.jackson.serialization.write-dates-as-timestamps=true</code>到你的配置。</p><p>新的<code>spring-boot-starter-json</code> starter 收集必要的位以读取和写入 JSON。它不仅提供了<code>jackson-databind</code>，与Java8 工作时也是有用的模块：<code>jackson-datatype-jdk8</code>，<code>jackson-datatype-jsr310</code>和<code>jackson-module-parameter-names</code>。以前您需要手动依赖这些模块，现在可以依靠这个新的 starter 。</p><h5 id="Spring-MVC-路径匹配默认行为更改"><a href="#Spring-MVC-路径匹配默认行为更改" class="headerlink" title="Spring MVC 路径匹配默认行为更改"></a>Spring MVC 路径匹配默认行为更改</h5><p>我们已决定在 Spring MVC 应用程序中更改后缀路径匹配的默认值（请参阅<a href="https://github.com/spring-projects/spring-boot/issues/11105" target="_blank" rel="noopener">＃11105</a>）。按照 Spring Framework 中记录的<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-suffix-pattern-match" target="_blank" rel="noopener">最佳实践</a>，此功能不再默认启用。</p><p>如果您的应用程序希望将请求<code>&quot;GET /projects/spring-boot.json&quot;</code>映射到<code>@GetMapping(&quot;/projects/spring-boot&quot;)</code>映射，则此更改会影响您。</p><p>有关此更多信息以及如何减轻此更改，请查阅<a href="https://docs.spring.io/spring-boot/docs/2.0.0.RC1/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-pathmatch" target="_blank" rel="noopener">Spring Boot中有关路径匹配和内容协商的参考文档</a>。</p><h5 id="Servlet-过滤器"><a href="#Servlet-过滤器" class="headerlink" title="Servlet 过滤器"></a>Servlet 过滤器</h5><p>Servlet 过滤器的默认调度程序类型现在是<code>DipatcherType.REQUEST</code>; 这使 Spring Boot 的默认值与 Servlet 规范的默认值一致。如果您希望将过滤器映射到其他调度程序类型，请使用<code>FilterRegistrationBean</code>注册您的过滤器。</p><p>注意：Spring Security 和 Spring Session 过滤器配置  <code>ASYNC</code>, <code>ERROR</code>以及 <code>REQUEST</code> 调度类型。</p><h5 id="RestTemplateBuilder"><a href="#RestTemplateBuilder" class="headerlink" title="RestTemplateBuilder"></a>RestTemplateBuilder</h5><p>该<code>requestFactory(ClientHttpRequestFactory)</code>方法已被新<code>requestFactory(Supplier&lt;ClientHttpRequestFactory&gt; requestFactorySupplier)</code>方法所取代。<code>Supplier</code>允许构建器生成的每个模板使用它自己的请求工厂，从而避免共享工厂可能导致的副作用。见<a href="https://github.com/spring-projects/spring-boot/issues/11255" target="_blank" rel="noopener">＃11255</a>。</p><h5 id="WebJars-定位器"><a href="#WebJars-定位器" class="headerlink" title="WebJars 定位器"></a>WebJars 定位器</h5><p>Spring Boot 1.x 使用并提供依赖关系管理<code>org.webjars:webjars-locator</code>。<code>webjars-locator</code>是一个<a href="https://github.com/webjars/webjars-locator/tree/ec6b793f2d6f031f6aa384a06c059ff499055652" target="_blank" rel="noopener">“命名不佳的库……包装<code>webjars-locator-core</code>项目”</a>。<code>org.webjars:webjars-locator</code>应该更新依赖项来<code>org.webjars:webjars-locator-core</code>代替使用。</p><h4 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h4><p>Spring Boot 2 极大地简化了默认的安全配置，并使添加定制安全变得简单。Spring Boot 现在具有一种行为，只要您添加自己的 <code>WebSecurityConfigurerAdapter</code> 就会退出，而不是进行多种与安全性相关的自动配置。</p><p>如果您使用以下任何属性，则会受到影响：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">security.basic.authorize-mode</span><br><span class="line">security.basic.enabled</span><br><span class="line">security.basic.path</span><br><span class="line">security.basic.realm</span><br><span class="line">security.enable-csrf</span><br><span class="line">security.headers.cache</span><br><span class="line">security.headers.content-security-policy</span><br><span class="line">security.headers.content-security-policy-mode</span><br><span class="line">security.headers.content-type</span><br><span class="line">security.headers.frame</span><br><span class="line">security.headers.hsts</span><br><span class="line">security.headers.xss</span><br><span class="line">security.ignored</span><br><span class="line">security.require-ssl</span><br><span class="line">security.sessions</span><br></pre></td></tr></table></figure><h5 id="默认安全"><a href="#默认安全" class="headerlink" title="默认安全"></a>默认安全</h5><p>安全自动配置不再公开选项，并尽可能使用 Spring Security 默认值。一个明显的副作用是使用 Spring Security 的内容协商进行授权（表单登录）。</p><h5 id="默认用户"><a href="#默认用户" class="headerlink" title="默认用户"></a>默认用户</h5><p>默认情况下，Spring Boot 使用生成的密码配置单个用户。用户可以使用 <code>spring.security.user.*</code> 属性进行配置。要进一步定制用户或添加其他用户，您将不得不公开一个<code>UserDetailsService</code>bean。</p><h5 id="AuthenticationManager-Bean"><a href="#AuthenticationManager-Bean" class="headerlink" title="AuthenticationManager Bean"></a>AuthenticationManager Bean</h5><p>如果您想将 Spring Security <code>AuthenticationManager</code>作为 bean 公开，请覆盖<code>authenticationManagerBean</code>您的方法<code>WebSecurityConfigurerAdapter</code>并为其添加注释<code>@Bean</code>。</p><h5 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h5><p>从功能的 <a href="http://projects.spring.io/spring-security-oauth/" target="_blank" rel="noopener">Spring Security OAuth 项目</a> 迁移到核心 <a href="https://projects.spring.io/spring-security/" target="_blank" rel="noopener">Spring Security</a>。不再为依赖关系提供依赖管理，Spring Boot 2 通过 Spring Security 5 提供 <a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-security-oauth2" target="_blank" rel="noopener">OAuth 2.0 客户端支持</a>。</p><p>如果您依赖尚未迁移的 Spring Security OAuth 功能，则需要在其他 jar 上添加依赖项，请查看<a href="https://docs.spring.io/spring-security-oauth2-boot/docs/current/reference/htmlsingle/" target="_blank" rel="noopener">文档</a>以获取更多详细信息。我们还继续支持 Spring Boot 1.5，以便旧版应用程序可以继续使用它，直到提供升级路径。</p><h5 id="执行器安全"><a href="#执行器安全" class="headerlink" title="执行器安全"></a>执行器安全</h5><p>执行器不再有单独的安全自动配置（<code>management.security.*</code>属性消失）。<code>sensitive</code>每个端点的标志也没有在安全配置中变得更加明确。如果您依赖于此行为，则需要创建或调整您的安全配置，以保护您选择角色的端点。</p><p>例如，假设以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">endpoints.flyway.sensitive=false</span><br><span class="line">endpoints.info.sensitive=true</span><br><span class="line">management.security.roles=MY_ADMIN</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">.authorizeRequests()</span><br><span class="line">.requestMatchers(EndpointRequest.to(<span class="string">"health"</span>, <span class="string">"flyway"</span>)).permitAll()</span><br><span class="line">.requestMatchers(EndpointRequest.toAnyEndpoint()).hasRole(<span class="string">"MY_ADMIN"</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>需要注意的是在<code>2.x</code>，<code>health</code>和<code>info</code>在默认情况下启用（与<code>health</code>默认情况下不显示其细节）。为了与这些新的默认值一致，<code>health</code>已被添加到第一个匹配器。</p><h4 id="使用-SQL-数据库"><a href="#使用-SQL-数据库" class="headerlink" title="使用 SQL 数据库"></a>使用 SQL 数据库</h4><h5 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h5><p>默认连接池已从 Tomcat 切换到 HikariCP。如果您过去<code>spring.datasource.type</code>在基于 Tomcat 的应用程序中强制使用 Hikari，现在可以删除重写。</p><p>特别是，如果你有这样的设置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zaxxer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>HikariCP<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在可以这样修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="WARN-消息隐含的’打开在视图’"><a href="#WARN-消息隐含的’打开在视图’" class="headerlink" title="WARN 消息隐含的’打开在视图’"></a>WARN 消息隐含的’打开在视图’</h5><p>从现在起，未明确启用的应用程序<code>spring.jpa.open-in-view</code>将在启动过程中收到警告消息。虽然这种行为是一种友好的默认行为，但如果您没有完全意识到为您做了什么，这可能会导致问题。此消息可确保您了解可在查看呈现期间执行数据库查询。如果你没有问题，你可以明确地配置这个属性来消除警告信息。</p><h5 id="JPA-和-Spring-Data"><a href="#JPA-和-Spring-Data" class="headerlink" title="JPA 和 Spring Data"></a>JPA 和 Spring Data</h5><p>在 Spring Boot 1.x 中，一些用户正在扩展<code>HibernateJpaAutoConfiguration</code>以将高级自定义应用于自动配置<code>EntityManagerFactory</code>。为了防止发生这种错误的用例，Spring Boot 2 中不再可能扩展它。</p><p>为了支持这些用例，现在可以定义一个<code>HibernatePropertiesCustomizer</code>bean，它可以完全控制 Hibernate 属性，包括注册在上下文中声明为 bean 的 Hibernate 拦截器的能力。</p><h5 id="Flyway"><a href="#Flyway" class="headerlink" title="Flyway"></a>Flyway</h5><p>Flyway 配置键被移动到<code>spring</code>命名空间（即<code>spring.flyway</code>）</p><p>升级到 Spring Boot 2 将会将 Flyway 升级<code>3.x</code>到<code>5.x</code>。为确保模式升级顺利进行，请按照以下说明操作：</p><ul><li>首先将您的<code>1.5.x</code>Spring Boot 应用程序升级到 Flyway 4，请参阅<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#using-boot-maven-parent-pom" target="_blank" rel="noopener">Maven</a>和<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/gradle-plugin/reference/html//#managing-dependencies-customizing" target="_blank" rel="noopener">Gradle</a>的说明。</li><li>一旦您的架构升级到了 Flyway 4，升级到 Spring Boot 2 并再次运行迁移以将您的应用程序移植到 Flyway 5。</li></ul><h5 id="Liquibase"><a href="#Liquibase" class="headerlink" title="Liquibase"></a>Liquibase</h5><p>Liquibase 配置键被移动到<code>spring</code>命名空间（即<code>spring.liquibase</code>）</p><h5 id="数据库初始化"><a href="#数据库初始化" class="headerlink" title="数据库初始化"></a>数据库初始化</h5><p>基本<code>DataSource</code>初始化现在仅针对嵌入式数据源启用，并将在您使用生产数据库时立即关闭。新的<code>spring.datasource.initialization-mode</code>（替换<code>spring.datasource.initialize</code>）提供更多的控制。</p><h5 id="更新默认的’创建-删除’处理"><a href="#更新默认的’创建-删除’处理" class="headerlink" title="更新默认的’创建 - 删除’处理"></a>更新默认的’创建 - 删除’处理</h5><p><code>spring.jpa.hibernate.ddl-auto</code> 属性默认为只有在没有使用 Liquibase 或 Flyway 等模式管理器时才使用嵌入式数据库进行创建。一旦检测到模式管理器，默认更改为 <code>none</code>。</p><h4 id="整合-NoSQL"><a href="#整合-NoSQL" class="headerlink" title="整合 NoSQL"></a>整合 NoSQL</h4><h5 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h5><p>现在使用的是 <a href="https://lettuce.io/" target="_blank" rel="noopener">Lettuce</a> 而不是 <a href="https://github.com/xetorthio/jedis" target="_blank" rel="noopener">Jedis</a> 作为 Redis 驱动程序<code>spring-boot-starter-redis</code>。如果您使用更高级别的Spring Data 构造，则应该发现变化是透明的。我们仍然支持 Jedis，如果您愿意，通过排除 <code>io.lettuce：lettuce-core</code>并添加 <code>redis.clients：jedis</code>，则可以自由切换依赖项。</p><h5 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h5><p>Elasticsearch 已经升级到 6.0+。与 <a href="https://www.elastic.co/blog/elasticsearch-the-server" target="_blank" rel="noopener">Elastic 宣布嵌入式 Elasticsearch 不再受支持一致</a>，自动配置<code>NodeClient</code>已被删除。<code>TransportClient</code>可以通过使用<code>spring.data.elasticsearch.cluster-nodes</code>提供要连接的一个或多个节点的地址来自动配置。</p><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>用于缓存的专用 Hazelcast 自动配置。</p><p>无法自动配置常规<code>HazelcastInstance</code>和专用<code>HazelcastInstance</code>缓存。因此，该<code>spring.cache.hazelcast.config</code>属性已不再可用。</p><h4 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h4><p>在启动时执行批处理作业的 CommandLineRunner 的顺序为 0。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><h5 id="Mockito-1-x"><a href="#Mockito-1-x" class="headerlink" title="Mockito 1.x"></a>Mockito 1.x</h5><p>Mockito 1.x 不再支持<code>@MockBean</code>和<code>@SpyBean</code>。如果你不用<code>spring-boot-starter-test</code>来管理你的依赖关系，你应该升级到 Mockito 2.x.</p><h3 id="Spring-Boot-Actuator"><a href="#Spring-Boot-Actuator" class="headerlink" title="Spring Boot Actuator"></a>Spring Boot Actuator</h3><p>Spring Boot 2 为 Actuator 带来了重要变化，无论是内部还是面向用户，请查阅<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready" target="_blank" rel="noopener">参考指南中</a>的<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#production-ready" target="_blank" rel="noopener">更新部分</a>和<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/actuator-api/html" target="_blank" rel="noopener">新的Actuator API文档</a>。</p><p>您应该期望编程模型，配置密钥和某些端点的响应格式发生变化。Actuator 现在在 Spring MVC，Spring WebFlux 和Jersey 上得到本地支持。</p><h4 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h4><p>Actuator 的代码分为两个模块：现有的<code>spring-boot-actuator</code>和新的<code>spring-boot-actuator-autoconfigure</code>。如果您使用原始模块（<code>spring-boot-actuator</code>）导入执行器，请考虑使用<code>spring-boot-starter-actuator</code>启动器替代它。</p><h4 id="Keys-的配置结构"><a href="#Keys-的配置结构" class="headerlink" title="Keys 的配置结构"></a>Keys 的配置结构</h4><p>Endpoints 基础配置 key 已经统一：</p><table><thead><tr><th style="text-align:center">旧的属性</th><th style="text-align:center">新的属性</th></tr></thead><tbody><tr><td style="text-align:center"><code>endpoints.&lt;id&gt;.*</code></td><td style="text-align:center"><code>management.endpoint.&lt;id&gt;.*</code></td></tr><tr><td style="text-align:center"><code>endpoints.cors.*</code></td><td style="text-align:center"><code>management.endpoints.web.cors.*</code></td></tr><tr><td style="text-align:center"><code>endpoints.jmx.*</code></td><td style="text-align:center"><code>management.endpoints.jmx.*</code></td></tr><tr><td style="text-align:center"><code>management.address</code></td><td style="text-align:center"><code>management.server.address</code></td></tr><tr><td style="text-align:center"><code>management.context-path</code></td><td style="text-align:center"><code>management.server.servlet.context-path</code></td></tr><tr><td style="text-align:center"><code>management.ssl.*</code></td><td style="text-align:center"><code>management.server.ssl.*</code></td></tr><tr><td style="text-align:center"><code>management.port</code></td><td style="text-align:center">management.server.port</td></tr></tbody></table><h4 id="基本路径"><a href="#基本路径" class="headerlink" title="基本路径"></a>基本路径</h4><p>所有 endpoints 默认情况下都已移至 <code>/actuator</code>。</p><p>我们修改了 <code>management.server.servlet.context-path</code> 的含义：它现在是 <code>server.servlet.context-path</code> 的端点管理等效物（只有在设置了 <code>management.server.port</code> 时才有效）。另外，您还可以使用新的单独属性为管理端点设置基本路径：<code>management.endpoints.web.base-path</code>。</p><p>例如，如果你设置<code>management.server.servlet.context-path=/management</code>和<code>management.endpoints.web.base-path=/application</code>，你就可以在下面的路径到达终点健康：<code>/management/application/health</code>。</p><p>如果你想恢复 1.x 的行为（即具有<code>/health</code>代替<code>/actuator/health</code>），设置以下属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.base-path=/</span><br></pre></td></tr></table></figure><h4 id="审计事件-API-更改"><a href="#审计事件-API-更改" class="headerlink" title="审计事件 API 更改"></a>审计事件 API 更改</h4><p><code>AuditEventRepository</code> 现在有一个包含所有可选参数的单一方法。</p><h4 id="Endpoints"><a href="#Endpoints" class="headerlink" title="Endpoints"></a>Endpoints</h4><p>要通过 HTTP 使执行器端点可用，它需要同时<strong>启用</strong>和<strong>公开</strong>。默认：</p><ul><li><strong>无论您的应用程序中是否存在和配置 Spring Security</strong>，只有端点<code>/health</code>和<code>/info</code>端点都是暴露的。</li><li>所有端点，但<code>/shutdown</code>已启用。</li></ul><p>您可以按如下方式公开所有端点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure><p>您可以通过以下方式显式启用<code>/shutdown</code>端点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoint.shutdown.enabled=true</span><br></pre></td></tr></table></figure><p>要公开所有（已启用）网络端点除<code>env</code>端点之外：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br><span class="line">management.endpoints.web.exposure.exclude=env</span><br></pre></td></tr></table></figure><h5 id="Endpoint-changes"><a href="#Endpoint-changes" class="headerlink" title="Endpoint changes"></a>Endpoint changes</h5><table><thead><tr><th>1.x 端点</th><th>2.0 端点（改变）</th></tr></thead><tbody><tr><td><code>/actuator</code></td><td>不再可用。 但是，在 <code>management.endpoints.web.base-path</code> 的根目录中有一个映射，它提供了到所有暴露端点的链接。</td></tr><tr><td><code>/auditevents</code></td><td>该<code>after</code>参数不再需要</td></tr><tr><td><code>/autoconfig</code></td><td>重命名为 <code>/conditions</code></td></tr><tr><td><code>/docs</code></td><td>不再可用</td></tr><tr><td><code>/health</code></td><td>现在有一个 <code>management.endpoint.health.show-details</code> 选项  <code>never</code>, <code>always</code>, <code>when-authenticated</code>，而不是依靠  <code>sensitive</code> 标志来确定 <code>health</code> 端点是否必须显示全部细节。  默认情况下，<code>/actuator/health</code>公开并且不显示细节。</td></tr><tr><td><code>/trace</code></td><td>重命名为 <code>/httptrace</code></td></tr></tbody></table><p>端点属性已更改如下：</p><ul><li><code>endpoints.&lt;id&gt;.enabled</code> 已经转移到了 <code>management.endpoint.&lt;id&gt;.enabled</code></li><li><code>endpoints.&lt;id&gt;.id</code> 没有替换（端点的 ID 不再可配置）</li><li><code>endpoints.&lt;id&gt;.sensitive</code>没有替代品（请参见<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide#actuator-security" target="_blank" rel="noopener">执行器安全</a>）</li><li><code>endpoints.&lt;id&gt;.path</code> 已经转移到了 <code>management.endpoints.web.path-mapping.&lt;id&gt;</code></li></ul><h4 id="端点格式"><a href="#端点格式" class="headerlink" title="端点格式"></a>端点格式</h4><h5 id="actuator-mappings-端点大改变"><a href="#actuator-mappings-端点大改变" class="headerlink" title="/actuator/mappings 端点大改变"></a><code>/actuator/mappings</code> 端点大改变</h5><p>JSON 格式已经更改为现在正确地包含有关上下文层次结构，多个<code>DispatcherServlets，</code>部署的 Servlet 和 Servlet 过滤器的信息。详情请参阅<a href="https://github.com/spring-projects/spring-boot/issues/9979#issuecomment-357930821" target="_blank" rel="noopener">＃9979</a>。</p><p>Actuator API 文档的<a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/actuator-api/html/#mappings" target="_blank" rel="noopener">相关部分</a>提供了一个示例文档。</p><h5 id="actuator-httptrace-端点大改变"><a href="#actuator-httptrace-端点大改变" class="headerlink" title="/actuator/httptrace 端点大改变"></a><code>/actuator/httptrace</code> 端点大改变</h5><p>响应的结构已经过改进，以反映端点关注跟踪 HTTP 请求 - 响应交换的情况。</p><h4 id="迁移自定义端点"><a href="#迁移自定义端点" class="headerlink" title="迁移自定义端点"></a>迁移自定义端点</h4><p>如果您有自定义执行器端点，请<a href="https://spring.io/blog/2017/08/22/introducing-actuator-endpoints-in-spring-boot-2-0" target="_blank" rel="noopener">查看专用博客文章</a>。该团队还撰写了一个 wiki 页面，介绍<a href="https://github.com/spring-projects/spring-boot/wiki/Migrating-a-custom-Actuator-endpoint-to-Spring-Boot-2" target="_blank" rel="noopener">如何将现有的执行器端点迁移</a>到新的基础架构。</p><h3 id="Metrics"><a href="#Metrics" class="headerlink" title="Metrics"></a>Metrics</h3><p>Spring Boot自己的指标已被支持取代，包括自动配置，用于 <a href="https://micrometer.io/" target="_blank" rel="noopener">icrometer</a>  和 dimensional 指标。</p><h4 id="设置-icrometer"><a href="#设置-icrometer" class="headerlink" title="设置 icrometer"></a>设置 icrometer</h4><p>如果您的 Spring Boot 2.0 应用程序已依赖于 Actuator，则 icrometer 已在此处并自动配置。如果您希望将度量标准导出到 Prometheus，Atlas 或 Datadog 等外部注册表，Micrometer 将为许多注册表提供依赖关系; 您可以使用<code>spring.metrics.*</code>属性配置您的应用程序以导出到特定的注册表。</p><h4 id="迁移定制计数器-量表"><a href="#迁移定制计数器-量表" class="headerlink" title="迁移定制计数器/量表"></a>迁移定制计数器/量表</h4><p>您可以通过以下方式创建各种指标，而不是在应用程序代码中注入<code>CounterService</code>或<code>GaugeService</code>实例化：</p><ul><li>注入<code>MeterRegistry</code>和调用方法。</li><li>直接调用静态方法<code>Counter featureCounter = Metrics.counter(&quot;feature&quot;);</code>。</li></ul><h3 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h3><h4 id="热拔插"><a href="#热拔插" class="headerlink" title="热拔插"></a>热拔插</h4><p>由于 Spring Loaded 项目已移至 attic，它在 Spring Boot 的支持已被删除。我们建议使用 Devtools。</p><h4 id="Devtools-远程调试隧道"><a href="#Devtools-远程调试隧道" class="headerlink" title="Devtools 远程调试隧道"></a>Devtools 远程调试隧道</h4><p>已经从 Devtools 中删除了对通过 HTTP 进行隧道远程调试的支持。</p><h3 id="已删除的功能"><a href="#已删除的功能" class="headerlink" title="已删除的功能"></a>已删除的功能</h3><p>以下功能不再可用：</p><ul><li>CRaSH 支持</li><li>Spring Mobile 的自动配置和依赖关系管理。</li><li>Spring Social 的自动配置和依赖关系管理。</li><li>依赖关系管理<code>commons-digester</code>。</li></ul><h3 id="依赖版本"><a href="#依赖版本" class="headerlink" title="依赖版本"></a>依赖版本</h3><p>以下库的最低支持版本已更改：</p><ul><li>Elasticsearch 5.6</li><li>Gradle 4</li><li>Hibernate 5.2</li><li>Jetty 9.4</li><li>Spring Framework 5</li><li>Spring Security 5</li><li>Tomcat 8.5</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide</a></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/" target="_blank" rel="noopener">Spring Boot 2.0 新特性详解</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fp3h0820m2j31hc0zkwxr.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;希望本文档将帮助您把应用程序迁移到 Spring Boot 2.0。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.0 新特性详解</title>
    <link href="http://yoursite.com/2018/03/06/SpringBoot2-new-features/"/>
    <id>http://yoursite.com/2018/03/06/SpringBoot2-new-features/</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-03-06T16:03:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fp34jn0xb3j31hc140aji.jpg" alt=""></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在 3 月 1 号，Spring Boot<code>2.0.0.RELEASE</code>正式发布，这是 Spring Boot1.0 发布 4 年之后第一次重大修订，因此有多的新功能和特性值得大家期待！下面带大家了解下 Spring Boot 2.0 中的新特性。</p><a id="more"></a><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-new-features/</a></p><h3 id="从-Spring-Boot-1-5-升级"><a href="#从-Spring-Boot-1-5-升级" class="headerlink" title="从 Spring Boot 1.5 升级"></a>从 Spring Boot 1.5 升级</h3><p>由于 Spring Boot 2.0 的改变幅度有点大，所以升级现有的程序可能会比平常更大一些。</p><p>如果你还在考虑是否要升级，这里推荐 DD 的博客文章：<a href="http://blog.didispace.com/spring-boot-2-release/" target="_blank" rel="noopener">Spring Boot 2.0 正式发布，升还是不升呢？</a></p><p>如果要升级可以参考我的另外一篇文章：<a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener">Spring Boot 2.0 迁移指南</a></p><p>如果您目前正在运行较早版本的 Spring Boot，我们强烈建议您在迁移到 Spring Boot 2.0 之前先升级到 Spring Boot 1.5。</p><h3 id="新的和值得注意的特性"><a href="#新的和值得注意的特性" class="headerlink" title="新的和值得注意的特性"></a>新的和值得注意的特性</h3><p>小技巧：检查 <a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Configuration-Changelog" target="_blank" rel="noopener">配置更改日志</a> 来获取配置更改的完整描述。</p><h3 id="起码-JDK-8-和支持-JDK-9"><a href="#起码-JDK-8-和支持-JDK-9" class="headerlink" title="起码 JDK 8 和支持 JDK 9"></a>起码 JDK 8 和支持 JDK 9</h3><p>Spring Boot 2.0 要求 Java 8 作为最低版本。许多现有的 API 已更新，以利用 Java 8 的特性，例如：接口上的默认方法，函数回调以及新的 API，如<code>javax.time</code>。如果您当前正在使用 Java 7 或更早版本，则在开发 Spring Boot 2.0 应用程序之前，您需要升级您的 JDK。</p><p>Spring Boot 2.0 通过了在 JDK 9 下的测试，可以在 JDK 9 下正常运行，。我们所有的 jar 包都在模块系统兼容性的清单中附带了自动模块名称条目。</p><h3 id="第三方库的升级"><a href="#第三方库的升级" class="headerlink" title="第三方库的升级"></a>第三方库的升级</h3><p>Spring Boot 2.0 建立在 Spring Framework 5 之上，并且需要 Spring Framework 5 。你可以通过  <a href="https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-5.x" target="_blank" rel="noopener">What’s New in Spring Framework 5.x</a>  了解 Spring 5 的新特性。并在继续之前查看其升级指南 <a href="https://github.com/spring-projects/spring-framework/wiki/Upgrading-to-Spring-Framework-5.x" target="_blank" rel="noopener">Upgrading to Spring Framework 5.x</a> 。</p><p>我们已尽可能升级到其他第三方库的最新稳定版本。 本版本中一些显着的依赖性升级包括：</p><ul><li>Tomcat 8.5</li><li>Flyway 5</li><li>Hibernate 5.2</li><li>Thymeleaf 3</li></ul><h3 id="Reactive-Spring"><a href="#Reactive-Spring" class="headerlink" title="Reactive Spring"></a>Reactive Spring</h3><p>Spring 产品组合中的许多项目现在都为开发<a href="https://github.com/reactive-streams/reactive-streams-jvm#reactive-streams" target="_blank" rel="noopener">反应式应用程序</a>提供一流的支持。反应性应用程序是完全异步和非阻塞的。它们旨在用于事件循环执行模型（而不是更传统的每个请求线程执行模型）。Spring 框架参考文档中的<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html" target="_blank" rel="noopener">“Web 反应堆栈”</a>部分为这个主题提供了一个很好的入门。</p><p>Spring Boot 2.0 通过自动配置和启动器 POM 完全支持反应式应用。Spring Boot 的内部本身也在必要时进行了更新，以提供反应性的反应（最明显的是我们的嵌入式服务器支持）。</p><h4 id="Spring-WebFlux＆WebFlux-fn"><a href="#Spring-WebFlux＆WebFlux-fn" class="headerlink" title="Spring WebFlux＆WebFlux.fn"></a>Spring WebFlux＆WebFlux.fn</h4><p>Spring WebFlux 是 Spring MVC 的完全非阻塞反应式替代方案。Spring Boot 为基于注释的 Spring WebFlux 应用程序以及 WebFlux.fn 提供了自动配置，WebFlux.fn 提供了更实用的样式 API。</p><p>要开始，请添加 <code>spring-boot-starter-webflux</code> 到 POM，它将提供由嵌入式 Netty 服务器支持的 Spring WebFlux。</p><h4 id="Reactive-Spring-Data"><a href="#Reactive-Spring-Data" class="headerlink" title="Reactive Spring Data"></a>Reactive Spring Data</h4><p>在底层技术支持的情况下，Spring Data 还为反应式应用程序提供支持。目前 Cassandra，MongoDB，Couchbase 和 Redis 都有反应式 API 支持。</p><p>Spring Boot 包含针对这些技术的特殊 starter-POMs，可为您提供启动所需的一切。例如，<code>spring-boot-starter-data-mongodb-reactive</code>包括对反应性 mongo 驱动程序和项目反应堆的依赖性。</p><h4 id="Reactive-Spring-Security"><a href="#Reactive-Spring-Security" class="headerlink" title="Reactive Spring Security"></a>Reactive Spring Security</h4><p>Spring Boot 2.0 可以充分利用 Spring Security 5.0 来保护您的反应式应用程序。当 Spring Security 位于类路径中时，会为 WebFlux 应用程序提供自动配置。</p><p>使用 WebFlux 的 Spring Security 访问规则可以通过<code>SecurityWebFilterChain</code>。如果你之前整合过 Spring MVC 和 Spring Security，应该会感到非常熟悉。有关更多详细信息，请参阅 <a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#boot-features-security-webflux" target="_blank" rel="noopener">Spring Boot 参考文档</a>和 <a href="https://docs.spring.io/spring-security/site/docs/5.0.0.RELEASE/reference/htmlsingle/#jc-webflux" target="_blank" rel="noopener">Spring Security 文档</a>。</p><h4 id="嵌入式-Netty-服务器"><a href="#嵌入式-Netty-服务器" class="headerlink" title="嵌入式 Netty 服务器"></a>嵌入式 Netty 服务器</h4><p>由于 WebFlux 不依赖于 Servlet API，我们现在可以首次为 Netty 作为嵌入式服务器提供支持。该<code>spring-boot-starter-webflux</code>  启动 POM 将拉取 Netty  4.1 和 <a href="https://github.com/reactor/reactor-netty" target="_blank" rel="noopener">Ractor Netty</a> 。</p><p>注意：您只能将 Netty 用作反应式服务器。不提供阻止 servlet API 支持。</p><h3 id="HTTP-2-支持"><a href="#HTTP-2-支持" class="headerlink" title="HTTP/2 支持"></a>HTTP/2 支持</h3><p>为 Tomcat，Undertow 和 Jetty 提供 HTTP / 2 支持。支持取决于所选的 Web 服务器和应用程序环境（因为 JDK 8 不支持该协议）。</p><p>如何配置 HTTP／2，请参考 <a href="https://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#howto-configure-http2" target="_blank" rel="noopener">官方文档</a> 。</p><h3 id="配置属性的绑定"><a href="#配置属性的绑定" class="headerlink" title="配置属性的绑定"></a>配置属性的绑定</h3><p>在 Spring Boot 2.0 中，用于绑定<code>Environment</code>属性的机制<code>@ConfigurationProperties</code>已经完全彻底修改。我们借此机会收紧了松散绑定的规则，并修复了 Spring Boot 1.x 中的许多不一致之处。</p><p>新的<code>Binder</code>API 也可以<code>@ConfigurationProperties</code>直接在你自己的代码之外使用。例如，下面将结合到<code>List</code>的<code>PersonName</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PersonName&gt; people = Binder.get(environment)</span><br><span class="line">    .bind(<span class="string">"my.property"</span>, Bindable.listOf(PersonName.class))</span><br><span class="line">    .orElseThrow(IllegalStateException::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><p>配置源可以像这样在 YAML 中表示：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">my:</span></span><br><span class="line"><span class="attr">  property:</span></span><br><span class="line"><span class="attr">  - first-name:</span> <span class="string">zhisheng</span></span><br><span class="line"><span class="attr">    last-name:</span> <span class="string">tian</span></span><br><span class="line"><span class="attr">  - first-name:</span> <span class="string">zhisheng</span></span><br><span class="line"><span class="attr">    last-name:</span> <span class="string">tian</span></span><br></pre></td></tr></table></figure><p>有关更新绑定规则的更多信息，<a href="https://github.com/spring-projects/spring-boot/wiki/Relaxed-Binding-2.0" target="_blank" rel="noopener">请参阅此Wiki页面</a>。</p><h4 id="配置起源"><a href="#配置起源" class="headerlink" title="配置起源"></a>配置起源</h4><p>YAML 文件和被 Spring Boot 加载的 Properties 文件现在包含<code>Origin</code>信息，可帮助您跟踪项目从何处加载的信息。有些 Spring Boot 特性利用了这个信息可以在适当的时候展示出来。</p><p>例如，<code>BindException</code>绑定失败时抛出的类是一个<code>OriginProvider</code>。这意味着原始信息可以很好地从故障分析器中显示出来。</p><p>另一个例子是<code>env</code>执行器端点，当它有可用时包含了原始信息。下面的代码片断显示该<code>spring.security.user.name</code>属性来自 jar 包中的 application.properties 文件的第 1行，第 27 列。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"applicationConfig: [classpath:/application.properties]"</span>,</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"spring.security.user.name"</span>: &#123;</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">"user"</span>,</span><br><span class="line">      <span class="attr">"origin"</span>: <span class="string">"class path resource [application.properties]:1:27"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转换器支持"><a href="#转换器支持" class="headerlink" title="转换器支持"></a>转换器支持</h4><p>Binding 利用了一个新的 <code>ApplicationConversionService</code> 类，它提供了一些对属性绑定特别有用的额外转换器。最引人注目的是转换器的<code>Duration</code>类型和分隔字符串。</p><p>该<code>Duration</code>转换器允许在任一 ISO-8601 格式中指定的持续时间，或作为一个简单的字符串（例如<code>10m</code>，10 分钟）。现有的属性已更改为始终使用<code>Duration</code>。该<code>@DurationUnit</code>注释通过设置如果没有指定所使用的单元确保向后兼容性。例如，Spring Boot 1.5 中需要秒数的属性现在必须<code>@DurationUnit(ChronoUnit.SECONDS)</code>确保一个简单的值，例如<code>10</code>实际使用的值<code>10s</code>。</p><p>分隔字符串转换允许您将简单绑定<code>String</code>到<code>Collection</code>或<code>Array</code>不必分割逗号。例如，LDAP <code>base-dn</code> 属性用 <code>@Delimiter(Delimiter.NONE)</code>，所以 LDAP DN（通常包含逗号）不会被错误解释。</p><h3 id="Gradle-插件"><a href="#Gradle-插件" class="headerlink" title="Gradle 插件"></a>Gradle 插件</h3><p>Spring Boot 的 Gradle 插件已在很大程度上进行了重新编写，以实现<a href="https://github.com/spring-projects/spring-boot/issues?utf8=%E2%9C%93&amp;q=label%3A%22theme%3A%20gradle-plugin%22%20milestone%3A2.0.0.M1%20" target="_blank" rel="noopener">许多重大改进</a>。您可以在其<a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/gradle-plugin/reference" target="_blank" rel="noopener">参考文献</a>和 <a href="https://docs.spring.io/spring-boot/docs/2.0.0.BUILD-SNAPSHOT/gradle-plugin/api" target="_blank" rel="noopener">API</a> 文档中阅读关于插件功能的更多信息。</p><p>Spring Boot 现在需要 Gradle 4.x. 如果您要升级使用 Gradle 的项目，请查看<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide" target="_blank" rel="noopener">迁移指南</a>。</p><h3 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h3><p>Spring Boot 2.0 现在包含对 Kotlin 1.2.x 的支持，并提供了<code>runApplication</code> ，一个使用 Kotlin 运行 Spring Boot 应用程序的方法。我们还公开和利用了 Kotlin 对其他 Spring 项目（如Spring Framework，Spring Data 和 Reactor）已添加到其最近版本中的支持。</p><p>有关更多信息，请参阅<a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#boot-features-kotlin" target="_blank" rel="noopener">参考文档</a>的<a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#boot-features-kotlin" target="_blank" rel="noopener">Kotlin支持部分</a>。</p><h3 id="Actuator-改进"><a href="#Actuator-改进" class="headerlink" title="Actuator 改进"></a>Actuator 改进</h3><p>在 Spring Boot 2.0 中 Actuator endpoints 有很大的改进。所有 HTTP Actuator endpoints 现在都在该<code>/actuator</code>路径下公开，并且生成的 JSON 有效负载得到了改进。</p><p>我们现在也不会在默认情况下暴露很多端点。如果您要升级现有的 Spring Boot 1.5 应用程序，请务必查看<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide" target="_blank" rel="noopener">迁移指南</a>并特别注意该<code>management.endpoints.web.exposure.include</code>属性。</p><h4 id="Actuator-JSON"><a href="#Actuator-JSON" class="headerlink" title="Actuator JSON"></a>Actuator JSON</h4><p>Spring Boot 2.0 改进了从许多端点返回的 JSON 有效负载。</p><p>现在许多端点都具有更精确地反映底层数据的 JSON。例如，<code>/actuator/conditions</code>终端（<code>/autoconfig</code>在Spring Boot 1.5中）现在有一个顶级<code>contexts</code>密钥来将结果分组<code>ApplicationContext</code>。</p><p>现在还使用 <a href="https://projects.spring.io/spring-restdocs/" target="_blank" rel="noopener">Spring REST Docs</a> 生成了广泛的 <a href="https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/actuator-api/html/" target="_blank" rel="noopener">REST API </a> <a href="https://projects.spring.io/spring-restdocs/" target="_blank" rel="noopener">文档，</a>并随每个版本发布。</p><h4 id="Jersey-and-WebFlux-支持"><a href="#Jersey-and-WebFlux-支持" class="headerlink" title="Jersey and WebFlux 支持"></a>Jersey and WebFlux 支持</h4><p>除了支持 Spring MVC 和 JMX，您现在可以在开发 Jersey 或 WebFlux 应用程序时访问执行器端点。Jersey 支持通过自定义 Jersey 提供<code>Resource</code>，WebFlux 使用自定义<code>HandlerMapping</code>。</p><h4 id="Hypermedia-links"><a href="#Hypermedia-links" class="headerlink" title="Hypermedia links"></a>Hypermedia links</h4><p>该<code>/actuator</code>端点现在提供了一个 HAL 格式的响应提供链接到所有活动端点（即使你没有 Spring HATEOAS 在classpath）。</p><h4 id="Actuator-Endpoints"><a href="#Actuator-Endpoints" class="headerlink" title="Actuator @Endpoints"></a>Actuator @Endpoints</h4><p>为了支持 Spring MVC，JMX，WebFlux 和 Jersey，我们为 Actuator @Endpoints 开发了一种新的编程模型。该<code>@Endpoint</code>注解可以与<code>@ReadOperation</code>，<code>@WriteOperation</code> 和 <code>@DeleteOperation</code> 组合使用开发 endpoints。</p><p>您还可以使用<code>@EndpointWebExtension</code>或<code>@EndpointJmxExtension</code>编写技术特定的增强功能到 endpoints。详细信息请参阅<a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#production-ready-endpoints-custom" target="_blank" rel="noopener">更新的参考文档</a>。</p><h4 id="Micrometer"><a href="#Micrometer" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>Spring Boot 2.0 不再提供自己的指标 API。相反，我们依靠 <a href="https://micrometer.io/" target="_blank" rel="noopener">micrometer.io</a> 来满足所有应用程序监视需求。</p><p>Micrometer 包括尺寸指标的支持，当与尺寸监测系统配对时，尺寸指标可以有效访问特定的指定度量标准，并且可以在其尺寸范围内向下钻取。</p><p>指标可以输出到各种系统和开箱即用的 Spring Boot 2.0，为 Atlas，Datadog，Ganglia，Graphite，Influx，JMX，New Relic，Prometheus，SignalFx，StatsD 和 Wavefront 提供支持。另外还可以使用简单的内存中度量标准。</p><p>集成随 JVM 指标（包括 CPU，内存，线程和 GC），Logback，Tomcat，Spring MVC＆提供<code>RestTemplate</code>。</p><p>有关更多详细信息，请参阅参考文档的更新<a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#production-ready-metrics" target="_blank" rel="noopener">“指标”部分</a>。</p><h3 id="数据支持"><a href="#数据支持" class="headerlink" title="数据支持"></a>数据支持</h3><p>除了上面提到的 <code>Reactive Spring Data</code> 支持外，在数据领域还进行了其他一些更新和改进。</p><h4 id="HikariCP"><a href="#HikariCP" class="headerlink" title="HikariCP"></a>HikariCP</h4><p>Spring Boot 2.0 中的默认数据库池技术已从 Tomcat Pool 切换到 HikariCP。我们发现 Hakari 提供了卓越的性能，我们的许多用户更喜欢 Tomcat Pool。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>数据库初始化逻辑在 Spring Boot 2.0 中已经合理化。Spring Batch，Spring Integration，Spring Session 和 Quartz的初始化现在仅在使用嵌入式数据库时才会默认发生。该<code>enabled</code>属性已被替换为更具表现力枚举。例如，如果你想一直执行 Spring Batch 的初始化，您可以设置<code>spring.batch.initialize-schema=always</code>。</p><p>如果 Flyway 或 Liquibase 正在管理您的 DataSource 的模式，并且您正在使用嵌入式数据库，Spring Boot 现在会自动关闭 Hibernate 的自动 DDL 功能。</p><h4 id="JOOQ"><a href="#JOOQ" class="headerlink" title="JOOQ"></a>JOOQ</h4><p>Spring Boot 2.0 现在基于 DataSource 自动检测 JOOQ 方言（类似于为 JPA 方言所做的）。<code>@JooqTest</code>是新引入的注解用来简化那些只有 JOOQ 必须被使用的测试。</p><h4 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h4><p>Spring Boot 自动配置的 <code>JdbcTemplate</code> 现在可以通过 <code>spring.jdbc.template</code> 属性进行自定义。此外，<code>NamedParameterJdbcTemplate</code>自动配置的内容会重用<code>JdbcTemplate</code>。</p><h4 id="Spring-Data-Web-配置"><a href="#Spring-Data-Web-配置" class="headerlink" title="Spring Data Web 配置"></a>Spring Data Web 配置</h4><p>Spring Boot 公开了一个新的<code>spring.data.web</code>配置名称空间，可以轻松配置分页和排序。</p><h4 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h4><p>Spring Boot 现在自动配置开源时间序列数据库 InfluxDB。要启用 InfluxDB 支持，您需要设置一个<code>spring.influx.url</code>属性，并将其包含<code>influxdb-java</code>在您的类路径中。</p><h4 id="Flyway-Liquibase-灵活配置"><a href="#Flyway-Liquibase-灵活配置" class="headerlink" title="Flyway/Liquibase 灵活配置"></a>Flyway/Liquibase 灵活配置</h4><p>如果仅提供自定义<code>url</code>或<code>user</code>属性，则 Flyway 和 Liquibase 的自动配置现在将重用标准数据源属性，而不是忽略它们。这使您可以创建一个自定义的数据源，仅用于所需信息的迁移。</p><h4 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h4><p>现在支持自定义 Hibernate 命名策略。对于高级场景，现在可以在上下文中定义<code>ImplicitNamingStrategy</code>或<code>PhysicalNamingStrategy</code>使用常规 bean。</p><p>现在也可以通过公开<code>HibernatePropertiesCustomizer</code>bean 来更加细致地定制 Hibernate 使用的属性。</p><h4 id="MongoDB-客户端自定义"><a href="#MongoDB-客户端自定义" class="headerlink" title="MongoDB 客户端自定义"></a>MongoDB 客户端自定义</h4><p>现在可以通过定义一个类型的 bean 来为 Spring Boot 自动配置的 Mongo 客户端应用高级定制<code>MongoClientSettingsBuilderCustomizer</code>。</p><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>现在可以使用<code>spring.cache.redis.*</code>属性配置 Redis 的缓存默认值。</p><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>除了上面提到的 WebFlux 和 WebFlux.fn 支持之外，还在开发 Web 应用程序时进行了以下改进。</p><h4 id="上下文路径记录"><a href="#上下文路径记录" class="headerlink" title="上下文路径记录"></a>上下文路径记录</h4><p>当使用嵌入式容器时，当您的应用程序启动时，上下文路径将与 HTTP 端口一起记录。例如，嵌入式 Tomcat 现在看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tomcat 在端口上启动：8080（http），其上下文路径为 &apos;/foo&apos;</span><br></pre></td></tr></table></figure><h4 id="Web过滤器初始化"><a href="#Web过滤器初始化" class="headerlink" title="Web过滤器初始化"></a>Web过滤器初始化</h4><p>Web 过滤器现在在所有支持的容器上急切地初始化。</p><h4 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h4><p>Thymeleaf 初始化现在包括<code>thymeleaf-extras-java8time</code>，提供<code>javax.time</code>类型支持。</p><h4 id="JSON-支持"><a href="#JSON-支持" class="headerlink" title="JSON 支持"></a>JSON 支持</h4><p>新的<code>spring-boot-starter-json</code>起始者收集必要的位以读取和写入 JSON。它不仅提供了<code>jackson-databind</code>与Java8 工作时，也是有用的模块：<code>jackson-datatype-jdk8</code>，<code>jackson-datatype-jsr310</code>和<code>jackson-module-parameter-names</code>。这个新的起动器现在被用于<code>jackson-databind</code>之前定义的地方。</p><p>如果您更喜欢 Jackson 之外的其他产品，我们对 GSON 的支持在 Spring Boot 2.0  已经大大提高。我们还引入了对 JSON-B 的支持（包括 JSON-B 测试支持）。</p><h3 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h3><p>自动配置支持目前包含了  <a href="http://www.quartz-scheduler.org/" target="_blank" rel="noopener">Quartz Scheduler</a>。我们还添加了新的<code>spring-boot-starter-quartz</code> 初始化 POM。</p><p>您可以使用内存<code>JobStores</code>中或完整的基于 JDBC 的存储。所有<code>JobDetail</code>，<code>Calendar</code>并<code>Trigger</code>从你的 Spring应用程序上下文豆将自动注册<code>Scheduler</code>。</p><p>有关更多详细信息，请阅读参考文档的新<a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#boot-features-quartz" target="_blank" rel="noopener">“Quartz Scheduler”部分</a>。</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>对 Spring Boot 2.0 中提供的测试支持进行了一些补充和调整：</p><ul><li><code>@WebFluxTest</code>已添加新注释以支持 WebFlux 应用程序的“切片”测试。</li><li><code>Converter</code>和<code>GenericConverter</code>豆类现在自动扫描<code>@WebMvcTest</code>和<code>@WebFluxTest</code>。</li><li><code>@AutoConfigureWebTestClient</code>已经添加了一个注释来提供一个<code>WebTestClient</code>bean 供测试使用。注释会自动应用于<code>@WebFluxTest</code>测试。</li><li>增加了一个新的<code>ApplicationContextRunner</code>测试实用程序，可以很容易地测试您的自动配置。我们已将大部分内部测试套件移至此新模型。详细信息请参阅<a href="http://docs.spring.io/spring-boot/docs/2.0.x-SNAPSHOT/reference/htmlsingle/#boot-features-test-autoconfig" target="_blank" rel="noopener">更新的文档</a>。</li></ul><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>除了上面列出的变化外，还有很多小的调整和改进，包括：</p><ul><li><code>@ConditionalOnBean</code>现在在确定是否满足条件时使用逻辑<code>AND</code>而不是逻辑<code>OR</code>。</li><li>无条件类现在包含在自动配置报告中。</li><li>该<code>spring</code>CLI 应用程序现在包括<code>encodepassword</code>可用于创建 Spring Security 的兼容散列密码命令。</li><li>计划任务（即 <code>@EnableScheduling</code>）可以使用<code>scheduledtasks</code>执行器端点进行审查。</li><li>该<code>loggers</code>驱动器终端现在允许你重新设置一个记录器级别为它的默认。</li><li>Spring Session 用户现在可以通过<code>sessions</code>执行器端点查找和删除会话。</li><li>使用<code>spring-boot-starter-parent</code>现在基于 Maven 的应用程序<code>-parameters</code>默认使用标志。</li><li>我们的构建现在使用 <a href="http://concourse.ci/" target="_blank" rel="noopener">concourse</a> 的 CI 和我们的项目 POM 文件已被重构，使它们更简单的。</li></ul><h3 id="动画-ASCII-艺术"><a href="#动画-ASCII-艺术" class="headerlink" title="动画 ASCII 艺术"></a>动画 ASCII 艺术</h3><p>最后，为了好玩，Spring Boot 2.0 现在支持动画 GIF 横幅。</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fp34jnoouij30dc093dfp.jpg" alt="animated-ascii-art"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="">https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1fp34jn0xb3j31hc140aji.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;在 3 月 1 号，Spring Boot&lt;code&gt;2.0.0.RELEASE&lt;/code&gt;正式发布，这是 Spring Boot1.0 发布 4 年之后第一次重大修订，因此有多的新功能和特性值得大家期待！下面带大家了解下 Spring Boot 2.0 中的新特性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>小马哥 《Java 微服务实践 - Spring Cloud 系列》强烈推荐</title>
    <link href="http://yoursite.com/2018/03/04/springcloud-vedio/"/>
    <id>http://yoursite.com/2018/03/04/springcloud-vedio/</id>
    <published>2018-03-03T16:00:00.000Z</published>
    <updated>2018-03-06T16:22:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fp0tsq2q8vj30dc07idg8.jpg" alt="u=1933229855,2353978820&amp;fm=27&amp;gp=0"></p><h3 id="视频内容"><a href="#视频内容" class="headerlink" title="视频内容"></a>视频内容</h3><p>Spring Cloud 系列课程致力于以实战的方式覆盖所有功能特性，结合小马哥十余年的学习方法和工作经验，体会作者设计意图。结合源码加深理解，最终达到形成系统性的知识和技术体系的目的。</p><a id="more"></a><h3 id="讲师介绍"><a href="#讲师介绍" class="headerlink" title="讲师介绍"></a>讲师介绍</h3><blockquote><p><strong>小马哥</strong>，一线互联网公司技术专家，十余年 Java EE 从业经验，架构师、微服务布道师。目前主要负责微服务技术实施、架构衍进、基础设施构建等。重点关注云计算、微服务以及软件架构等领域。通过 SUN Java（SCJP、SCWCD、SCBCD）以及 Oracle OCA 等的认证。</p></blockquote><h3 id="视频列表"><a href="#视频列表" class="headerlink" title="视频列表"></a>视频列表</h3><p>1、<a href="https://segmentfault.com/l/1500000011384570" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（一）云原生应用</a></p><p>2、<a href="https://segmentfault.com/l/1500000011385195" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（二）配置客户端</a></p><p>3、<a href="https://segmentfault.com/l/1500000011385904" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（三）配置服务器</a></p><p>4、<a href="https://segmentfault.com/l/1500000011386051" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（四）服务发现/注册</a></p><p>5、<a href="https://segmentfault.com/l/1500000011386082" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（五）高可用服务治理</a></p><p>6、<a href="https://segmentfault.com/l/1500000011386110" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（六）负载均衡</a></p><p>7、<a href="https://segmentfault.com/l/1500000011386180" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（七）Ribbon 源码</a></p><p>8、<a href="https://segmentfault.com/l/1500000011386237" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（八）服务短路</a></p><p>9、<a href="https://segmentfault.com/l/1500000011386273" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（九）Hystrix源码</a></p><p>10、<a href="https://segmentfault.com/l/1500000011386274" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十）服务调用</a></p><p>11、<a href="https://segmentfault.com/l/1500000011386451" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十一）服务网关</a></p><p>12、<a href="https://segmentfault.com/l/1500000011386642" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十二）消息驱动整合</a></p><p>13、<a href="https://segmentfault.com/l/1500000011386655" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十三）Binder实现</a></p><p>14、<a href="https://segmentfault.com/l/1500000011386685" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十四）消息总线</a></p><p>15、<a href="https://segmentfault.com/l/1500000011386721" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十五）分布式应用跟踪</a></p><p>16、<a href="https://segmentfault.com/l/1500000011386751" target="_blank" rel="noopener">Java 微服务实践 - Spring Cloud 系列（十六）系列回顾</a></p><h3 id="购买链接"><a href="#购买链接" class="headerlink" title="购买链接"></a>购买链接</h3><p>你可以使用下面链接购买（有优惠的哦）</p><p><strong><a href="https://segmentfault.com/ls/1650000011386794?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011386794?r=bPrFW3</a></strong></p><p>或者你也可以扫描下面的二维码购买（同样也有优惠的哦）</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fp0td2936xj308c0aujsd.jpg" alt="sc视频"></p><h3 id="课程评价"><a href="#课程评价" class="headerlink" title="课程评价"></a>课程评价</h3><blockquote><p>1、小马哥讲的很好，实践和原理一起结合讲，理解的很深刻。<br>期待小马哥的下一个高并发的系列讲座，还有那本万众瞩目的新书<br>2、<br>这些系列课程怎么说呢，就我来说其实学的不是知识，是学习方法。小马哥厉害的，给个赞。<br>3、满满的赞，社会套路太多，须加强学习，期待下期与小马哥相逢<br>4、基本是都是守者直播时间，跟着 Spring Boot 系列和 Spring Cloud 系列的课程，小马哥讲得很有启发性。讲一种技术的从哪里来，解决了什么问题，以及优缺点。讲源码又不仅限制于源码。总的来说值得花时间来学习和讨论的。值得推荐，五星好评。<br>5、可以的，解答问题很耐心。从你这学到了浏览JSR等之类的规范，在用一些框架的时候发现国外的，很多都实现了JSR，比如spring batch，而国内的话，个人觉得这方面稍微差了点，这方面我们还要努力，加油！</p></blockquote><p>以上评价摘自 segmentfault</p><h3 id="相关课程"><a href="#相关课程" class="headerlink" title="相关课程"></a>相关课程</h3><p><strong>Java 微服务实践 - Spring Boot 系列</strong></p><p>优惠地址：<strong><a href="https://segmentfault.com/ls/1650000011063780?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011063780?r=bPrFW3</a></strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0td375okj308c0augml.jpg" alt="sb视频"></p><p>另外：还有这个 <strong>Java 微服务实践 - Spring Boot / Spring Cloud</strong>，算是两个的合集了，合买的话优惠更大。</p><p>优惠地址：<strong><a href="https://segmentfault.com/ls/1650000011387052?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011387052?r=bPrFW3</a></strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fp0td1fomnj308c0au75b.jpg" alt="sb-sc合集"></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t1k9vd8j3076076mxo.jpg" alt="C6LG3mGa12"></p><p>建了个不错的微信群，如果有感兴趣的可以加我微信，然后拉你进群交流。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t1jn6s4j30qi0z10x1.jpg" alt="1520091522031"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fp0tsq2q8vj30dc07idg8.jpg&quot; alt=&quot;u=1933229855,2353978820&amp;amp;fm=27&amp;amp;gp=0&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;视频内容&quot;&gt;&lt;a href=&quot;#视频内容&quot; class=&quot;headerlink&quot; title=&quot;视频内容&quot;&gt;&lt;/a&gt;视频内容&lt;/h3&gt;&lt;p&gt;Spring Cloud 系列课程致力于以实战的方式覆盖所有功能特性，结合小马哥十余年的学习方法和工作经验，体会作者设计意图。结合源码加深理解，最终达到形成系统性的知识和技术体系的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>小马哥 《Java 微服务实践 - Spring Boot 系列》强烈推荐</title>
    <link href="http://yoursite.com/2018/03/04/springboot-vedio/"/>
    <id>http://yoursite.com/2018/03/04/springboot-vedio/</id>
    <published>2018-03-03T16:00:00.000Z</published>
    <updated>2018-03-06T16:20:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp0ts4i1hfj30id08t3yn.jpg" alt="timg"></p><h3 id="视频内容"><a href="#视频内容" class="headerlink" title="视频内容"></a>视频内容</h3><p>Java 微服务实践 - Spring Boot 为系列讲座，二十节专题直播，时长高达50个小时，包括目前最流行技术，深入源码分析，授人以渔的方式，帮助初学者深入浅出地掌握，为高阶从业人员抛砖引玉。</p><a id="more"></a><h3 id="讲师介绍"><a href="#讲师介绍" class="headerlink" title="讲师介绍"></a>讲师介绍</h3><blockquote><p><strong>小马哥</strong>，一线互联网公司技术专家，十余年 Java EE 从业经验，架构师、微服务布道师。目前主要负责微服务技术实施、架构衍进、基础设施构建等。重点关注云计算、微服务以及软件架构等领域。通过 SUN Java（SCJP、SCWCD、SCBCD）以及 Oracle OCA 等的认证。</p></blockquote><h3 id="视频列表"><a href="#视频列表" class="headerlink" title="视频列表"></a>视频列表</h3><p>1、<a href="https://segmentfault.com/l/1500000009515571" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（一）初体验</a></p><p>2、<a href="https://segmentfault.com/l/1500000009659111" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（二） Web篇（上）</a></p><p>3、<a href="https://segmentfault.com/l/1500000009767025" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（三）Web篇（中）</a></p><p>4、<a href="https://segmentfault.com/l/1500000009830944" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（四）Web篇（下）</a></p><p>5、<a href="https://segmentfault.com/l/1500000009844304" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（五）嵌入式Web容器</a></p><p>6、<a href="https://segmentfault.com/l/1500000009904190" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（六）数据库 JDBC</a></p><p>7、<a href="https://segmentfault.com/l/1500000009952220" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（七）MyBatis</a></p><p>8、<a href="https://segmentfault.com/l/1500000009952527" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（八）JPA</a></p><p>9、<a href="https://segmentfault.com/l/1500000009957330" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（九）NoSQL</a></p><p>10、<a href="https://segmentfault.com/l/1500000009970812" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十）缓存</a></p><p>11、<a href="https://segmentfault.com/l/1500000009971600" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十一）消息</a></p><p>12、<a href="https://segmentfault.com/l/1500000009971716" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十二）验证</a></p><p>13、<a href="https://segmentfault.com/l/1500000009971764" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（十三）WebSocket</a></p><p>14、<a href="https://segmentfault.com/l/1500000009978309" target="_blank" rel="noopener"> Java 微服务实践- Spring Boot 系列（十四）WebService</a></p><p>15、<a href="https://segmentfault.com/l/1500000009978481" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十五）安全</a></p><p>16、<a href="https://segmentfault.com/l/1500000009978585" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（十六）日志</a></p><p>17、<a href="https://segmentfault.com/l/1500000009978661" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（十七）监管</a></p><p>18、<a href="https://segmentfault.com/l/1500000009978729" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（十八）配置</a></p><p>19、<a href="https://segmentfault.com/l/1500000009978826" target="_blank" rel="noopener"> Java 微服务实践 - Spring Boot 系列（十九）测试</a></p><p>20、<a href="https://segmentfault.com/l/1500000009978904" target="_blank" rel="noopener">Java 微服务实践 - Spring Boot 系列（二十）自定义启动器</a></p><h3 id="购买链接"><a href="#购买链接" class="headerlink" title="购买链接"></a>购买链接</h3><p>你可以使用下面链接购买（有优惠的哦）</p><p><strong><a href="https://segmentfault.com/ls/1650000011063780?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011063780?r=bPrFW3</a></strong></p><p>或者你也可以扫描下面的二维码购买（同样也有优惠的哦）</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t6idjt0j308c0augml.jpg" alt="sb视频"></p><h3 id="课程评价"><a href="#课程评价" class="headerlink" title="课程评价"></a>课程评价</h3><blockquote><p>1、小马哥讲的好详细，以前似是而非的东东，现在都懂了<br>2、学到了怎么使用，也学到了怎么自定义校验，知其然也知其所以然<br>3、6666 起飞了 websocket 之前看了写 这次更加深入和标准化 感谢小马哥带来的干货<br>4、深入浅出，思路清晰。<br>5、深入浅出啊。非常好，而且如果有问题，不管简单还是难的，都从不同的角度和层次来解答了。学到的东西非常多。谢谢。</p></blockquote><p>以上评价摘自 segmentfault</p><h3 id="相关课程"><a href="#相关课程" class="headerlink" title="相关课程"></a>相关课程</h3><p><strong>Java 微服务实践 - Spring Cloud 系列</strong></p><p>优惠地址：<strong><a href="https://segmentfault.com/ls/1650000011386794?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011386794?r=bPrFW3</a></strong></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0tc1p3e1j308c0aujsd.jpg" alt="sc视频"></p><p>另外：还有这个 <strong>Java 微服务实践 - Spring Boot / Spring Cloud</strong>，算是两个的合集了，合买的话优惠更大。</p><p>优惠地址：<strong><a href="https://segmentfault.com/ls/1650000011387052?r=bPrFW3" target="_blank" rel="noopener">https://segmentfault.com/ls/1650000011387052?r=bPrFW3</a></strong></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp0tc1df8vj308c0au75b.jpg" alt="sb-sc合集"></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t1k9vd8j3076076mxo.jpg" alt="C6LG3mGa12"></p><p>建了个不错的微信群，如果有感兴趣的可以加我微信，然后拉你进群交流。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fp0t1jn6s4j30qi0z10x1.jpg" alt="1520091522031"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fp0ts4i1hfj30id08t3yn.jpg&quot; alt=&quot;timg&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;视频内容&quot;&gt;&lt;a href=&quot;#视频内容&quot; class=&quot;headerlink&quot; title=&quot;视频内容&quot;&gt;&lt;/a&gt;视频内容&lt;/h3&gt;&lt;p&gt;Java 微服务实践 - Spring Boot 为系列讲座，二十节专题直播，时长高达50个小时，包括目前最流行技术，深入源码分析，授人以渔的方式，帮助初学者深入浅出地掌握，为高阶从业人员抛砖引玉。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>《深入理解 Java 内存模型》读书笔记</title>
    <link href="http://yoursite.com/2018/02/28/Java-Memory-Model/"/>
    <id>http://yoursite.com/2018/02/28/Java-Memory-Model/</id>
    <published>2018-02-27T16:00:00.000Z</published>
    <updated>2018-03-06T16:13:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7l5mj64j31hc0zbh9n.jpg" alt="fairyland-canyon-1632749_1920"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>《深入理解 Java 内存模型》程晓明著，该书在以前看过一遍，现在学的东西越多，感觉那块越重要，于是又再细看一遍，于是便有了下面的读书笔记总结。全书页数虽不多，内容讲得挺深的。细看的话，也是挺花时间的，看完收获绝对挺大的。也建议 Java 开发者都去看看。里面主要有 Java 内存模型的基础、重排序、顺序一致性、Volatile 关键字、锁、final。本文参考书中内容。</p><a id="more"></a><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p>如果你想查看这本书可以关注我的公众号: <strong>zhisheng</strong> ，然后里面回复关键字 <strong>JMM</strong> 可以查看我分享的百度云链接。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/02/28/Java-Memory-Model/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/28/Java-Memory-Model/</a></p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="并发编程的模型分类"><a href="#并发编程的模型分类" class="headerlink" title="并发编程的模型分类"></a>并发编程的模型分类</h4><p>在并发编程需要处理的两个关键问题是：<strong>线程之间如何通信</strong> 和 <strong>线程之间如何同步</strong>。</p><h5 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h5><p><strong>通信</strong> 是指线程之间以何种机制来交换信息。在命令式编程中，线程之间的通信机制有两种：<strong>共享内存</strong> 和 <strong>消息传递</strong>。</p><p>在<strong>共享内存</strong>的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的<strong>公共状态</strong>来<strong>隐式</strong>进行通信。</p><p>在<strong>消息传递</strong>的并发模型里，线程之间没有公共状态，线程之间必须通过明确的<strong>发送消息</strong>来<strong>显式</strong>进行通信。</p><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p><strong>同步</strong> 是指程序用于控制不同线程之间操作发生相对顺序的机制。</p><p>在<strong>共享内存</strong>的并发模型里，同步是<strong>显式</strong>进行的。程序员必须显式指定某个方法或某段代码需要在线程之间<strong>互斥执行</strong>。</p><p>在<strong>消息传递</strong>的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是<strong>隐式</strong>进行的。</p><p>Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p><h4 id="Java-内存模型的抽象"><a href="#Java-内存模型的抽象" class="headerlink" title="Java 内存模型的抽象"></a>Java 内存模型的抽象</h4><p>在 Java 中，所有实例域、静态域 和 数组元素存储在堆内存中，堆内存在线程之间共享。局部变量、方法定义参数 和 异常处理器参数 不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p><p>Java 线程之间的通信由 Java 内存模型（JMM）控制。JMM 决定了一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程与主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每一个线程都有一个自己私有的本地内存，本地内存中存储了该变量以读／写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。</p><p>JMM 抽象示意图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l9q3hsj30zi0rq41t.jpg" alt="jmm"></p><p>从上图来看，如果线程 A 和线程 B 要通信的话，要如下两个步骤：</p><p>1、线程 A 需要将本地内存 A 中的共享变量副本刷新到主内存去</p><p>2、线程 B 去主内存读取线程 A 之前已更新过的共享变量</p><p>步骤示意图：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7lh7qm2j30wo0ocq58.jpg" alt="tongxin"></p><p>举个例子：</p><p>本地内存 A 和 B 有主内存共享变量 X 的副本。假设一开始时，这三个内存中 X 的值都是 0。线程 A 正执行时，把更新后的 X 值（假设为 1）临时存放在自己的本地内存 A 中。当线程 A 和 B 需要通信时，线程 A 首先会把自己本地内存 A 中修改后的 X 值刷新到主内存去，此时主内存中的 X 值变为了 1。随后，线程 B 到主内存中读取线程 A 更新后的共享变量 X 的值，此时线程 B 的本地内存的 X 值也变成了 1。</p><p>整体来看，这两个步骤实质上是线程 A 再向线程 B 发送消息，而这个通信过程必须经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 Java 程序员提供内存可见性保证。</p><h3 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三类：</p><p>1、<strong>编译器优化的重排序</strong>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p><p>2、<strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p><p>3、<strong>内存系统的重排序</strong>。由于处理器使用缓存和读／写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p><p>从 Java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7l4iv44j313e07wmyw.jpg" alt="sort-again"></p><p>上面的这些重排序都可能导致多线程程序出现内存可见性问题。对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。对于处理器重排序，JMM 的处理器重排序规则会要求 Java 编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。</p><p>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><h4 id="处理器重排序"><a href="#处理器重排序" class="headerlink" title="处理器重排序"></a>处理器重排序</h4><p>现代的处理器使用<strong>写缓冲区</strong>来临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！</p><p>举个例子：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l6udu0j30uc0c8zls.jpg" alt="example1"></p><p>假设处理器A和处理器B按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0。具体的原因如下图所示：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7lftsaxj30wg0mcwgz.jpg" alt="exam1-ans"></p><p>处理器 A 和 B 同时把共享变量写入在写缓冲区中（A1、B1），然后再从内存中读取另一个共享变量（A2、B2），最后才把自己写缓冲区中保存的脏数据刷新到内存中（A3、B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。</p><p>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1 -&gt; A2，但内存操作实际发生的顺序却是：A2 -&gt; A1。此时，处理器 A 的内存操作顺序被重排序了。</p><p>这里的关键是，由于<strong>写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致</strong>。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作重排序。</p><h4 id="内存屏障指令"><a href="#内存屏障指令" class="headerlink" title="内存屏障指令"></a>内存屏障指令</h4><p>为了保证内存可见性，Java 编译器在生成指令序列的适当位置会插入<strong>内存屏障指令</strong>来禁止特定类型的处理器重排序。JMM 把内存屏障指令分为下列四类：</p><table><thead><tr><th>屏障类型</th><th style="text-align:center">指令示例</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td>LoadLoad Barriers</td><td style="text-align:center">Load1; LoadLoad; Load2</td><td style="text-align:center">确保 Load1 数据的装载，之前于 Load2 及所有后续装载指令的装载。</td></tr><tr><td>StoreStore Barriers</td><td style="text-align:center">Store1; StoreStore; Store2</td><td style="text-align:center">确保 Store1 数据对其他处理器可见（刷新到内存），之前于 Store2 及所有后续存储指令的存储。</td></tr><tr><td>LoadStore Barriers</td><td style="text-align:center">Load1; LoadStore; Store2</td><td style="text-align:center">确保 Load1 数据装载，之前于 Store2 及所有后续的存储指令刷新到内存。</td></tr><tr><td>StoreLoad Barriers</td><td style="text-align:center">Store1; StoreLoad; Load2</td><td style="text-align:center">确保 Store1 数据对其他处理器变得可见（指刷新到内存），之前于 Load2 及所有后续装载指令的装载。<strong>StoreLoadBarriers 会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令</strong>。</td></tr></tbody></table><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>JSR-133 内存模型使用 happens-before 的概念来阐述操作之间的内存可见性。在 JMM 中，如果<strong>一个操作执行的结果需要对另一个操作可见</strong>，那么这两个操作之间必须要存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p><p>与程序员密切相关的 happens-before 规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器的解锁，happens-before 于随后对这个监视器的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果  A happens-before B，且 B happens-before C，那么 A happens-before C。</li></ul><p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。</p><p>happens-before 与 JMM 的关系如下图所示：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7l7e9zij312s0titdo.jpg" alt="happens-before-jmm"></p><p>如上图所示，一个 happens-before 规则对应于一个或多个编译器和处理器重排序规则。</p><h4 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h4><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分下列三种类型：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">代码示例</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">写后读</td><td style="text-align:center">a = 1;   b = a;</td><td style="text-align:center">写一个变量之后，再读这个位置。</td></tr><tr><td style="text-align:center">写后写</td><td style="text-align:center">a = 1;  a = 2;</td><td style="text-align:center">写一个变量之后，再写这个变量。</td></tr><tr><td style="text-align:center">读后写</td><td style="text-align:center">a = b;  b = 1;</td><td style="text-align:center">读一个变量之后，再写这个变量。</td></tr></tbody></table><p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p><p>前面提到过，编译器和处理器可能会对操作做重排序。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。</p><p>注意，这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p><h4 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h4><p>as-if-serial 语义的意思指：<strong>不管怎么重排序</strong>（编译器和处理器为了提高并行度），（单线程）<strong>程序的执行结果不能被改变</strong>。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。</p><p>为了遵守 as-if-serial 编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是如果操作之间没有数据依赖关系，这些操作就可能被编译器和处理器重排序。</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14;     //A</span><br><span class="line">double r  = 1.0;       //B</span><br><span class="line">double area = pi * r * r;     //C</span><br></pre></td></tr></table></figure><p>上面三个操作的数据依赖关系如下图所示：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7l7q6paj30fa0aoq33.jpg" alt="abc"></p><p>如上图所示，A 和 C 之间存在数据依赖关系，同时 B 和 C 之间也存在数据依赖关系。因此在最终执行的指令序列中，C 不能被重排序到 A 和 B 的前面（C 排到 A 和 B 的前面，程序的结果将会被改变）。但 A 和 B 之间没有数据依赖关系，编译器和处理器可以重排序 A 和 B 之间的执行顺序。下图是该程序的两种执行顺序：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7l97fx2j30zu0cwdh1.jpg" alt="2018-02-27_16-52-44"></p><p>在计算机中，软件技术和硬件技术有一个共同的目标：在不改变程序执行结果的前提下，尽可能的开发并行度。编译器和处理器遵从这一目标，从 happens-before 的定义我们可以看出，JMM 同样遵从这一目标。</p><h4 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h4><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;<span class="comment">//1</span></span><br><span class="line">    flag = <span class="keyword">true</span>;<span class="comment">//2</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;<span class="comment">//3</span></span><br><span class="line">      <span class="keyword">int</span> i = a * a;<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于操作 1 和 2 没有数据依赖关系，编译器和处理器可以对这两个操作重排序；操作 3 和操作 4 没有数据依赖关系，编译器和处理器也可以对这两个操作重排序。</p><p>1、当操作 1 和操作 2 重排序时，可能会产生什么效果？</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7lcgkgej30tw0ki3zd.jpg" alt="sort12"></p><p>如上图所示，操作 1 和操作 2 做了重排序。程序执行时，线程 A 首先写标记变量 flag，随后线程 B 读这个变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，在这里多线程程序的语义被重排序破坏了！</p><p>2、当操作 3 和操作 4 重排序时会产生什么效果（借助这个重排序，可以顺便说明控制依赖性）。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7l4zjfkj30zy0owq4r.jpg" alt="sort34"></p><p>在程序中，操作 3 和操作 4 存在<strong>控制依赖关系</strong>。当代码中存在控制依赖性时，<strong>会影响指令序列执行的并行度</strong>。为此，编译器和处理器会采用<strong>猜测</strong>（Speculation）执行来克服控制相关性对并行度的影响。以处理器的猜测执行为例，执行线程 B 的处理器可以提前读取并计算 a * a，然后把计算结果临时保存到一个名为重排序缓冲（reorder buffer ROB）的硬件缓存中。当接下来操作 3 的条件判断为真时，就把该计算结果写入变量 i 中。</p><p>从图中我们可以看出，猜测执行实质上对操作3和4做了重排序。重排序在这里破坏了多线程程序的语义！</p><p>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是 as-if-serial 语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。</p><h3 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h3><h4 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h4><p>顺序一致性内存模型有两大特性：</p><ul><li>一个线程中的所有操作必须按照程序的顺序来执行。</li><li>（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li></ul><p>顺序一致性内存模型为程序员提供的视图如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7l6dyuaj30sk0mumyg.jpg" alt="2018-02-27_17-55-09"></p><p>在概念上，顺序一致性模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读/写操作。从上面的示意图我们可以看出，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，图中的开关装置能把所有线程的所有内存读/写操作串行化。</p><p>举个例子：</p><p>假设有两个线程 A 和 B 并发执行。其中 A 线程有三个操作，它们在程序中的顺序是：A1 -&gt; A2 -&gt; A3。B 线程也有三个操作，它们在程序中的顺序是：B1 -&gt; B2 -&gt; B3。</p><p>假设这两个线程使用监视器锁来正确同步：A 线程的三个操作执行后释放监视器锁，随后 B 线程获取同一个监视器锁。那么程序在顺序一致性模型中的执行效果将如下图所示：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7ldkj04j31440paaee.jpg" alt="2018-02-27_18-01-51"></p><p>现在我们再假设这两个线程没有做同步，下面是这个未同步程序在顺序一致性模型中的执行示意图：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7lefk10j316c0nytd8.jpg" alt="2018-02-27_18-04-20"></p><p>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程 A 和 B 看到的执行顺序都是：B1 -&gt; A1 -&gt; A2 -&gt; B2 -&gt; A3 -&gt; B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。</p><p>但是，在 JMM 中就没有这个保证。未同步程序在 JMM 中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。比如，在当前线程把写过的数据缓存在本地内存中，在还没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，会认为这个写操作根本还没有被当前线程执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才能对其他线程可见。在这种情况下，当前线程和其它线程看到的操作执行顺序将不一致。</p><h4 id="同步程序的顺序一致性效果"><a href="#同步程序的顺序一致性效果" class="headerlink" title="同步程序的顺序一致性效果"></a>同步程序的顺序一致性效果</h4><p>下面我们对前面的示例程序用锁来同步，看看正确同步的程序如何具有顺序一致性。</p><p>请看下面的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;<span class="comment">//获取锁</span></span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">  &#125;<span class="comment">//释放锁</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">      <span class="keyword">int</span> i = a;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面示例代码中，假设 A 线程执行 write() 方法后，B 线程执行 reade() 方法。这是一个正确同步的多线程程序。根据JMM规范，该程序的执行结果将与该程序在顺序一致性模型中的执行结果相同。下面是该程序在两个内存模型中的执行时序对比图：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7ld04ffj312s0tq432.jpg" alt="2018-02-27_22-01-59"></p><p>在顺序一致性模型中，所有操作完全按程序的顺序执行。而在 JMM 中，临界区内的代码可以重排序（但 JMM 不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM 会在退出临界区和进入临界区这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图。虽然线程 A 在临界区内做了重排序，但由于监视器的互斥执行的特性，这里的线程 B 根本无法“观察”到线程 A 在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</p><p>从这里我们可以看到 JMM 在具体实现上的基本方针：在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。</p><h4 id="未同步程序的执行特性"><a href="#未同步程序的执行特性" class="headerlink" title="未同步程序的执行特性"></a>未同步程序的执行特性</h4><p>未同步程序在 JMM 中的执行时，整体上是无序的，其执行结果无法预知。未同步程序在两个模型中的执行特性有下面几个差异：</p><ol><li>顺序一致性模型保证单线程内的操作会按程序的顺序执行，而 JMM  不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。</li><li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而 JMM 不保证所有线程能看到一致的操作执行顺序。</li><li><strong>JMM 不保证对 64 位的 long 型和 double 型变量的读/写操作具有原子性</strong>，而<strong>顺序一致性模型保证对所有的内存读/写操作都具有原子</strong> 。</li></ol><p>第三个差异与处理器总线的工作机制密切相关。在计算机中，数据通过总线在处理器和内存之间传递。每次处理器和内存之间的数据传递都是通过<strong>总线事务</strong>来完成的。总线事务包括读事务和写事务。读事务从内存传送数据到处理器，写事务从处理器传递数据到内存，每个事务会读／写内存中一个或多个物理上连续的字。总线会同步试图并发使用总线的事务。在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和 I／O 设备执行内存的读／写。</p><p>总线的工作机制：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fow7levu1fj30zm0rgmzu.jpg" alt="2018-02-27_22-53-53"></p><p>如上图所示，假设处理器 A、B、和 C  同时向总线发起总线事务，这时总线仲裁会对竞争作出裁决，假设总线在仲裁后判定处理器 A 在竞争中获胜（总线仲裁会确保所有处理器都能公平的访问内存）。此时处理器 A 继续它的总线事务，而其它两个处理器则要等待处理器 A 的总线事务完成后才能开始再次执行内存访问。假设在处理器 A 执行总线事务期间（不管这个总线事务是读事务还是写事务），处理器 D 向总线发起了总线事务，此时处理器 D 的这个请求会被总线禁止。</p><p>总线的这些工作机制可以<strong>把所有处理器对内存的访问以串行化的方式来执行</strong>；<strong>在任意时间点，最多只能有一个处理器能访问内存</strong>。这个特性<strong>确保了单个总线事务之中的内存读/写操作具有原子性</strong>。</p><p>在一些 32 位的处理器上，如果要求对 64 位数据的写操作具有原子性，会有比较大的开销。为了照顾这种处理器，Java 语言规范鼓励但不强求 JVM 对 64 位的 long 型变量和 double 型变量的写具有原子性。当 JVM 在这种处理器上运行时，会把一个 64 位 long/ double 型变量的写操作拆分为两个 32 位的写操作来执行。这两个 32 位的写操作可能会被分配到不同的总线事务中执行，此时对这个 64 位变量的写将不具有原子性。</p><p>当单个内存操作不具有原子性，将可能会产生意想不到后果。请看下面示意图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l88o2aj312i0l8jt0.jpg" alt="2018-02-27_23-06-59"></p><p>如上图所示，假设处理器 A 写一个 long 型变量，同时处理器 B 要读这个 long 型变量。处理器 A 中 64 位的写操作被拆分为两个 32 位的写操作，且这两个 32 位的写操作被分配到不同的写事务中执行。同时处理器 B 中 64 位的读操作被分配到单个的读事务中执行。当处理器 A 和 B 按上图的时序来执行时，处理器 B 将看到仅仅被处理器 A “写了一半“的无效值。</p><p>注意，在 JSR -133 之前的旧内存模型中，一个 64 位 long/ double 型变量的<strong>读/写</strong>操作可以被拆分为两个 32 位的读/写操作来执行。从 JSR -133 内存模型开始（即从JDK5开始），仅仅只允许把一个 64 位 long/ double 型变量的<strong>写</strong>操作拆分为两个 32 位的写操作来执行，<strong>任意的读操作在JSR -133中都必须具有原子性</strong>（即任意读操作必须要在单个读事务中执行）。</p><h3 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h3><h4 id="Volatile-特性"><a href="#Volatile-特性" class="headerlink" title="Volatile 特性"></a>Volatile 特性</h4><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> a = <span class="number">1L</span>; <span class="comment">// 使用 volatile 声明 64 位的 long 型</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        a = l;                  <span class="comment">//单个 volatile 变量的写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;               <span class="comment">//单个 volatile 变量的读</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncreament</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++;                    <span class="comment">// 复合（多个） volatile 变量的读 /写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有多个线程分别调用上面程序的三个方法，这个程序在语义上和下面程序等价：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = <span class="number">1L</span>; <span class="comment">// 64 位的 long 型普通变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;<span class="comment">//对单个普通变量的写用同一个锁同步</span></span><br><span class="line">        a = l;                </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">get</span><span class="params">()</span> </span>&#123;<span class="comment">//对单个普通变量的读用同一个锁同步</span></span><br><span class="line">        <span class="keyword">return</span> a;           </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAndIncreament</span><span class="params">()</span> </span>&#123;<span class="comment">//普通方法调用</span></span><br><span class="line">      <span class="keyword">long</span> temp = get();<span class="comment">//调用已同步的读方法</span></span><br><span class="line">        temp += <span class="number">1L</span>;<span class="comment">//普通写操作</span></span><br><span class="line">      set(temp);<span class="comment">//调用已同步的写方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面示例程序所示，对一个 volatile 变量的单个读/写操作，与对一个普通变量的读/写操作使用同一个锁来同步，它们之间的执行效果相同。</p><p>锁的 happens-before 规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着<strong>对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入</strong>。</p><p>锁的语义决定了临界区代码的执行具有原子性。这意味着即使是 64 位的 long 型和 double 型变量，只要它是 volatile变量，对该变量的读写就将具有原子性。<strong>如果是多个 volatile 操作或类似于 volatile++ 这种复合操作，这些操作整体上不具有原子性</strong>。</p><p>简而言之，volatile 变量自身具有下列特性：</p><ul><li>可见性。对一个 volatile 变量的读，总是能看到（任意线程）对这个 volatile 变量最后的写入。</li><li>原子性：对任意单个 volatile 变量的读/写具有原子性，但类似于 volatile++ 这种复合操作不具有原子性。</li></ul><h4 id="volatile-写-读的内存定义"><a href="#volatile-写-读的内存定义" class="headerlink" title="volatile 写-读的内存定义"></a>volatile 写-读的内存定义</h4><ul><li>当<strong>写</strong>一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</li><li>当<strong>读</strong>一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li></ul><p>假设上面的程序 flag 变量用 volatile 修饰</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7lak6kvj30xc0qc76l.jpg" alt="2018-02-28_10-13-39"></p><h4 id="volatile-内存语义的实现"><a href="#volatile-内存语义的实现" class="headerlink" title="volatile 内存语义的实现"></a>volatile 内存语义的实现</h4><p>下面是 JMM 针对编译器制定的 volatile 重排序规则表：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7lg83wdj313u0ckmz8.jpg" alt="2018-02-28_10-26-43"></p><p>为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p>下面是基于保守策略的 JMM 内存屏障插入策略：</p><ul><li>在每个 volatile 写操作的前面插入一个 StoreStore 屏障。</li><li>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。</li><li>在每个 volatile 读操作的后面插入一个 LoadStore 屏障。</li></ul><p>下面是保守策略下，volatile 写操作 插入内存屏障后生成的指令序列示意图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7la65xnj31100lc76r.jpg" alt="2018-02-28_10-31-14"></p><p>下面是在保守策略下，volatile 读操作 插入内存屏障后生成的指令序列示意图：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fow7l35uyuj310w0myju1.jpg" alt="2018-02-28_10-38-12"></p><p>上述 volatile 写操作和 volatile 读操作的内存屏障插入策略非常保守。在实际执行时，只要不改变 volatile 写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="锁释放和获取的内存语义"><a href="#锁释放和获取的内存语义" class="headerlink" title="锁释放和获取的内存语义"></a>锁释放和获取的内存语义</h4><p>当线程释放锁时，JMM 会把该线程对应的本地内存中的共享变量刷新到主内存中。</p><p>当线程获取锁时，JMM 会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须要从主内存中去读取共享变量。</p><h4 id="锁内存语义的实现"><a href="#锁内存语义的实现" class="headerlink" title="锁内存语义的实现"></a>锁内存语义的实现</h4><p>借助 ReentrantLock 来讲解，PS： 后面专门讲下这块（ReentrantLock、Synchronized、公平锁、非公平锁、AQS等），可以看看大明哥的博客：<a href="">http://cmsblogs.com/?p=2210</a></p><h4 id="concurrent-包的实现"><a href="#concurrent-包的实现" class="headerlink" title="concurrent 包的实现"></a>concurrent 包的实现</h4><p>如果我们仔细分析 concurrent 包的源代码实现，会发现一个通用化的实现模式：</p><ol><li>首先，声明共享变量为 volatile；</li><li>然后，使用 CAS 的原子条件更新来实现线程之间的同步；</li><li>同时，配合以 volatile 的读/写和 CAS 所具有的 volatile 读和写的内存语义来实现线程之间的通信。</li></ol><p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic 包中的类），这些 concurrent 包中的基础类都是使用这种模式来实现的，而 concurrent 包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent 包的实现示意图如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l42rbpj31160qa77a.jpg" alt="2018-02-28_14-58-32"></p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>对于 final 域，编译器和处理器要遵守两个重排序规则：</p><ol><li>在构造函数内对一个 final 域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作之间不能重排序。</li></ol><h4 id="写-final-域的重排序规则"><a href="#写-final-域的重排序规则" class="headerlink" title="写 final 域的重排序规则"></a>写 final 域的重排序规则</h4><p>写 final 域的重排序规则禁止把 final 域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：</p><ul><li>JMM 禁止编译器把 final 域的写重排序到构造函数之外。</li><li>编译器会在 final 域的写之后，构造函数 return 之前，插入一个 StoreStore 屏障。这个屏障禁止处理器把 final 域的写重排序到构造函数之外。</li></ul><h4 id="读-final-域的重排序规则"><a href="#读-final-域的重排序规则" class="headerlink" title="读 final 域的重排序规则"></a>读 final 域的重排序规则</h4><p>在一个线程中，初次读对象引用与初次读该对象包含的 final 域，JMM 禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读 final 域操作的前面插入一个 LoadLoad 屏障。</p><h4 id="final-域是引用类型"><a href="#final-域是引用类型" class="headerlink" title="final 域是引用类型"></a>final 域是引用类型</h4><p>对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：</p><p>在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="JMM，处理器内存模型与顺序一致性内存模型之间的关系"><a href="#JMM，处理器内存模型与顺序一致性内存模型之间的关系" class="headerlink" title="JMM，处理器内存模型与顺序一致性内存模型之间的关系"></a>JMM，处理器内存模型与顺序一致性内存模型之间的关系</h4><p>JMM 是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。下面是语言内存模型，处理器内存模型和顺序一致性内存模型的强弱对比示意图：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7l8rgjej30ys0r6n05.jpg" alt="2018-02-28_15-34-39"></p><h4 id="JMM-的设计示意图"><a href="#JMM-的设计示意图" class="headerlink" title="JMM 的设计示意图"></a>JMM 的设计示意图</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fow7lb5c5kj310y0z4q7w.jpg" alt="jmm-"></p><h4 id="JMM-的内存可见性保证"><a href="#JMM-的内存可见性保证" class="headerlink" title="JMM 的内存可见性保证"></a>JMM 的内存可见性保证</h4><p>Java 程序的内存可见性保证按程序类型可以分为下列三类：</p><p>1.单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</p><p>2.正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是 JMM 关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</p><p>3.未同步/未正确同步的多线程程序。JMM 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）。</p><p>下图展示了这三类程序在 JMM 中与在顺序一致性内存模型中的执行结果的异同：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fow7lgmupij311m0sqtcg.jpg" alt="2018-02-28_15-43-10"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fow7l5mj64j31hc0zbh9n.jpg&quot; alt=&quot;fairyland-canyon-1632749_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;《深入理解 Java 内存模型》程晓明著，该书在以前看过一遍，现在学的东西越多，感觉那块越重要，于是又再细看一遍，于是便有了下面的读书笔记总结。全书页数虽不多，内容讲得挺深的。细看的话，也是挺花时间的，看完收获绝对挺大的。也建议 Java 开发者都去看看。里面主要有 Java 内存模型的基础、重排序、顺序一致性、Volatile 关键字、锁、final。本文参考书中内容。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="JMM" scheme="http://yoursite.com/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot RocketMQ 整合使用和监控</title>
    <link href="http://yoursite.com/2018/02/07/SpringBoot-RocketMQ/"/>
    <id>http://yoursite.com/2018/02/07/SpringBoot-RocketMQ/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-03-06T16:20:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fo8vqfuapwj31hc0zhtro.jpg" alt="photoshop-2845779_1920"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>通过前面两篇文章可以简单的了解 RocketMQ 和 安装 RocketMQ ，今天就将 SpringBoot 和 RocketMQ 整合起来使用。<br><a id="more"></a></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">SpringBoot Kafka 整合使用</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合使用</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/01/27/SpringBoot-ActiveMQ/" target="_blank" rel="noopener">SpringBoot ActiveMQ 整合使用</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/" target="_blank" rel="noopener">Kafka 安装及快速入门</a></p><p>5、<a href="http://www.54tianzhisheng.cn/2018/01/28/RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合进阶版</a></p><p>6、<a href="http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/" target="_blank" rel="noopener">RocketMQ 初探</a></p><p>7、<a href="http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/" target="_blank" rel="noopener">RocketMQ 安装及快速入门</a></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/02/07/SpringBoot-RocketMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/07/SpringBoot-RocketMQ/</a></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在 IDEA 创建一个 SpringBoot 项目，项目结构如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fo8vq6ufg3j30pe0yoacc.jpg" alt="rocketmq01"></p><h4 id="pom-文件"><a href="#pom-文件" class="headerlink" title="pom 文件"></a>pom 文件</h4><p>引入 RocketMQ 的一些相关依赖，最后的 pom 文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zhisheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>rocketmq<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot RocketMQ<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>application.properties 中如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 消费者的组名</span><br><span class="line">apache.rocketmq.consumer.PushConsumer=PushConsumer</span><br><span class="line"># 生产者的组名</span><br><span class="line">apache.rocketmq.producer.producerGroup=Producer</span><br><span class="line"># NameServer地址</span><br><span class="line">apache.rocketmq.namesrvAddr=localhost:9876</span><br></pre></td></tr></table></figure><h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rocketmq.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/2/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产者的组名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.producer.producerGroup&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String producerGroup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NameServer 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.namesrvAddr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultMQProducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生产者的组名</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(producerGroup);</span><br><span class="line">        <span class="comment">//指定NameServer地址，多个地址以 ; 隔开</span></span><br><span class="line">        producer.setNamesrvAddr(namesrvAddr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Producer对象在使用之前必须要调用start初始化，初始化一次即可</span></span><br><span class="line"><span class="comment">             * 注意：切记不可以在每次发送消息时，都调用start方法</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            producer.start();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//创建一个消息实例，包含 topic、tag 和 消息体</span></span><br><span class="line">             <span class="comment">//如下：topic 为 "TopicTest"，tag 为 "push"</span></span><br><span class="line">            Message message = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>, <span class="string">"push"</span>, <span class="string">"发送消息----zhisheng-----"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line"></span><br><span class="line">            StopWatch stop = <span class="keyword">new</span> StopWatch();</span><br><span class="line">            stop.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                SendResult result = producer.send(message);</span><br><span class="line">                System.out.println(<span class="string">"发送响应：MsgId:"</span> + result.getMsgId() + <span class="string">"，发送状态:"</span> + result.getSendStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            stop.stop();</span><br><span class="line">            System.out.println(<span class="string">"----------------发送一万条消息耗时："</span> + stop.getTotalTimeMillis());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            producer.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rocketmq.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.consumer.ConsumeFromWhere;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/2/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费者的组名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.consumer.PushConsumer&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * NameServer 地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;apache.rocketmq.namesrvAddr&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String namesrvAddr;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultMQPushConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//消费者的组名</span></span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(consumerGroup);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定NameServer地址，多个地址以 ; 隔开</span></span><br><span class="line">        consumer.setNamesrvAddr(namesrvAddr);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//订阅PushTopic下Tag为push的消息</span></span><br><span class="line">            consumer.subscribe(<span class="string">"TopicTest"</span>, <span class="string">"push"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费</span></span><br><span class="line">            <span class="comment">//如果非第一次启动，那么按照上次消费的位置继续消费</span></span><br><span class="line">            consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">            consumer.registerMessageListener((MessageListenerConcurrently) (list, context) -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt messageExt : list) &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"messageExt: "</span> + messageExt);<span class="comment">//输出消息内容</span></span><br><span class="line"></span><br><span class="line">                        String messageBody = <span class="keyword">new</span> String(messageExt.getBody(), RemotingHelper.DEFAULT_CHARSET);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"消费响应：msgId : "</span> + messageExt.getMsgId() + <span class="string">",  msgBody : "</span> + messageBody);<span class="comment">//输出消息内容</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER; <span class="comment">//稍后再试</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS; <span class="comment">//消费成功</span></span><br><span class="line">            &#125;);</span><br><span class="line">            consumer.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rocketmq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketmqApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(RocketmqApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><p>代码已经都写好了，接下来我们需要将与 RocketMQ 有关的启动起来。</p><h4 id="启动-Name-Server"><a href="#启动-Name-Server" class="headerlink" title="启动 Name Server"></a>启动 Name Server</h4><p>在前面文章中已经写过怎么启动，<a href="http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/#%E5%90%AF%E5%8A%A8-NameServer" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/#%E5%90%AF%E5%8A%A8-NameServer</a></p><p>进入到目录 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd distribution/target/apache-rocketmq</span><br></pre></td></tr></table></figure><p>启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line"></span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log //通过日志查看是否启动成功</span><br></pre></td></tr></table></figure><h4 id="启动-Broker"><a href="#启动-Broker" class="headerlink" title="启动 Broker"></a>启动 Broker</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line"></span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log//通过日志查看是否启动成功</span><br></pre></td></tr></table></figure><p>然后运行启动类，运行效果如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fo8vqiq0jvj31kw0x1x6m.jpg" alt="2018-02-07_22-21-14"></p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>RocketMQ有一个对其扩展的开源项目 ocketmq-console ，如今也提交给了 Apache ，地址在：<a href="">https://github.com/apache/rocketmq-externals/tree/master/rocketmq-console</a> ，官方也给出了其支持的功能的中文文档：<a href="">https://github.com/apache/rocketmq-externals/blob/master/rocketmq-console/doc/1_0_0/UserGuide_CN.md</a> ， 那么该如何安装？</p><h4 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h4><p>1、获取 Docker 镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull styletang/rocketmq-console-ng</span><br></pre></td></tr></table></figure><p>2、运行，注意将你自己的 NameServer 地址替换下面的 127.0.0.1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=127.0.0.1:9876 -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot; -p 8080:8080 -t styletang/rocketmq-console-ng</span><br></pre></td></tr></table></figure><h4 id="非-Docker-安装"><a href="#非-Docker-安装" class="headerlink" title="非 Docker 安装"></a>非 Docker 安装</h4><p>我们 git clone 一份代码到本地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/apache/rocketmq-externals.git</span><br><span class="line"></span><br><span class="line">cd rocketmq-externals/rocketmq-console/</span><br></pre></td></tr></table></figure><p>需要 jdk 1.7 以上。  执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn spring-boot:run</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br><span class="line"></span><br><span class="line">java -jar target/rocketmq-console-ng-1.0.0.jar</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>1、如果你下载依赖缓慢，你可以重新设置 maven 的 mirror 为阿里云的镜像</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span>        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、如果你使用的 RocketMQ 版本小于 3.5.8，如果您使用 rocketmq &lt; 3.5.8，请在启动 rocketmq-console-ng 时添加 <code>-Dcom.rocketmq.sendMessageWithVIPChannel = false</code>（或者您可以在 ops 页面中更改它）</p><p>3、更改 resource / application.properties 中的 rocketmq.config.namesrvAddr（或者可以在ops页面中更改它）</p><h3 id="错误解决方法"><a href="#错误解决方法" class="headerlink" title="错误解决方法"></a>错误解决方法</h3><p>1、Docker 启动项目报错</p><p><code>org.apache.rocketmq.remoting.exception.RemotingConnectException: connect to &lt;null&gt; failed</code></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fo8vqhpxcrj31kw0qc4ln.jpg" alt="2018-02-07_23-28-51"></p><p>将 Docker 启动命令改成如下以后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e &quot;JAVA_OPTS=-Drocketmq.config.namesrvAddr=127.0.0.1:9876 -Drocketmq.config.isVIPChannel=false&quot; -p 8080:8080 -t styletang/rocketmq-console-ng</span><br></pre></td></tr></table></figure><p>报错信息改变了，新的报错信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ERROR op=global_exception_handler_print_error</span><br><span class="line"></span><br><span class="line">org.apache.rocketmq.console.exception.ServiceException: This date have&apos;t data!</span><br></pre></td></tr></table></figure><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fo8vql4zvij31kw0vz1kx.jpg" alt="2018-02-08_00-23-15"></p><p>看到网上有人也遇到这个问题，他们都通过自己的方式解决了，但是方法我都试了，不适合我。不得不说，阿里，你能再用心点吗？既然把 RocketMQ 捐给 Apache 了，这些文档啥的都必须更新啊，不要还滞后着呢，不然少不了被吐槽！</p><p> 搞了很久这种方法没成功，暂时放弃！mmp</p><p>2、非 Docker 安装，只好把源码编译打包了。</p><p>1) 注意需要修改如下图中的配置：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vq7xv71j31kw0nktmi.jpg" alt="2018-02-08_10-26-03"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rocketmq.config.namesrvAddr=localhost:9876//注意替换你自己的ip</span><br><span class="line"></span><br><span class="line">#如果你 rocketmq 版本小于 3.5.8 才需设置 `rocketmq.config.isVIPChannel` 为 false，默认是 true, 这个可以在源码中可以看到的</span><br><span class="line">rocketmq.config.isVIPChannel=</span><br></pre></td></tr></table></figure><p>2) 执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>编译成功：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vqk3r9ej31kw0tsh2z.jpg" alt="2018-02-08_10-41-35"></p><p>可以看到已经打好了 jar 包：</p><p>运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar rocketmq-console-ng-1.0.0.jar</span><br></pre></td></tr></table></figure><p>成功，不报错了，开心😄，访问 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vqdzp1kj31kw0vyqap.jpg" alt="2018-02-08_11-06-26"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fo8vqlthfqj31e20liwgz.jpg" alt="2018-02-08_11-08-01"></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fo8vqgsrl8j31kw09pjur.jpg" alt="2018-02-08_11-09-16"></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fo8vqaazsyj31kw0p8qce.jpg" alt="2018-02-08_11-09-31"></p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fo8vqbosxvj31kw0vowp0.jpg" alt="2018-02-08_11-09-47"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vqet48yj31kw0bsmzk.jpg" alt="2018-02-08_11-10-03"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vq8q3v9j31kw0dfn0m.jpg" alt="2018-02-08_11-10-22"></p><p>整个监控大概就是这些了。</p><p>然后我运行之前的 SpringBoot 整合项目，查看监控信息如下：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fo8vqcyj00j31kw0up46m.jpg" alt="2018-02-08_11-22-11"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整篇文章讲述了 SpringBoot 与 RocketMQ 整合和 RocketMQ 监控平台的搭建。</p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p>1、<a href="">http://www.ymq.io/2018/02/02/spring-boot-rocketmq-example/#%E6%96%B0%E5%8A%A0%E9%A1%B9%E7%9B%AE</a></p><p>2、GitHub 官方 README</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fo8vqfuapwj31hc0zhtro.jpg&quot; alt=&quot;photoshop-2845779_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;通过前面两篇文章可以简单的了解 RocketMQ 和 安装 RocketMQ ，今天就将 SpringBoot 和 RocketMQ 整合起来使用。&lt;br&gt;
    
    </summary>
    
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ 简单的消息示例</title>
    <link href="http://yoursite.com/2018/02/07/rocketmq-example/"/>
    <id>http://yoursite.com/2018/02/07/rocketmq-example/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-03-06T16:18:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fo6h2isc2lj31hc0vhaqg.jpg" alt="father-and-son-2258681_1920"></p><p>使用 RocketMQ 以三种方式发送消息：可靠的同步，可靠的异步和单向传输。<br><a id="more"></a></p><h3 id="可靠的同步传输"><a href="#可靠的同步传输" class="headerlink" title="可靠的同步传输"></a>可靠的同步传输</h3><p>应用：可靠的同步传输广泛应用于重要通知消息，短信通知，短信营销系统等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span></span><br><span class="line">            DefaultMQProducer(<span class="string">"please_rename_unique_group_name"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">"%s%n"</span>, sendResult);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可靠的异步传输"><a href="#可靠的异步传输" class="headerlink" title="可靠的异步传输"></a>可靠的异步传输</h3><p>应用：异步传输一般用于响应时间敏感的业务场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        producer.setRetryTimesWhenSendAsyncFailed(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">                <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span>,</span><br><span class="line">                    <span class="string">"TagA"</span>,</span><br><span class="line">                    <span class="string">"OrderID188"</span>,</span><br><span class="line">                    <span class="string">"Hello world"</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                producer.send(msg, <span class="keyword">new</span> SendCallback() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(SendResult sendResult)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d OK %s %n"</span>, index,</span><br><span class="line">                            sendResult.getMsgId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onException</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                        System.out.printf(<span class="string">"%-10d Exception %s %n"</span>, index, e);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单向传输"><a href="#单向传输" class="headerlink" title="单向传输"></a>单向传输</h3><p>应用：单向传输用于需要中等可靠性的情况，例如日志收集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnewayProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//Instantiate with a producer group name.</span></span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">"ExampleProducerGroup"</span>);</span><br><span class="line">        <span class="comment">//Launch the instance.</span></span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//Create a message instance, specifying topic, tag and message body.</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">"TopicTest"</span> <span class="comment">/* Topic */</span>,</span><br><span class="line">                <span class="string">"TagA"</span> <span class="comment">/* Tag */</span>,</span><br><span class="line">                (<span class="string">"Hello RocketMQ "</span> +</span><br><span class="line">                    i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">//Call send message to deliver message to one of brokers.</span></span><br><span class="line">            producer.sendOneway(msg);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Shut down once the producer instance is not longer in use.</span></span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文是 RocketMQ 的三种发送消息的方式。</p><p>转发请注明地址：<a href="http://www.54tianzhisheng.cn/2018/02/07/rocketmq-example/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/07/rocketmq-example/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1fo6h2isc2lj31hc0vhaqg.jpg&quot; alt=&quot;father-and-son-2258681_1920&quot;&gt;&lt;/p&gt;
&lt;p&gt;使用 RocketMQ 以三种方式发送消息：可靠的同步，可靠的异步和单向传输。&lt;br&gt;
    
    </summary>
    
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ 安装及快速入门</title>
    <link href="http://yoursite.com/2018/02/06/RocketMQ-install/"/>
    <id>http://yoursite.com/2018/02/06/RocketMQ-install/</id>
    <published>2018-02-05T16:00:00.000Z</published>
    <updated>2018-03-06T16:18:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo5pxy3w8oj31hc0u0b29.jpg" alt="tree-3097419_1920"></p><p>如果你对 RocketMQ 还没了解，建议先看下上一篇文章：<a href="http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/" target="_blank" rel="noopener">RocketMQ 初探</a></p><a id="more"></a><h3 id="安装条件"><a href="#安装条件" class="headerlink" title="安装条件"></a>安装条件</h3><ol><li>64位操作系统，建议使用 Linux / Unix / Mac;</li><li>64位JDK 1.8+;</li><li>Maven 3.2.x</li></ol><h3 id="下载和构建"><a href="#下载和构建" class="headerlink" title="下载和构建"></a>下载和构建</h3><p>从 <a href="https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.2.0/rocketmq-all-4.2.0-source-release.zip" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.2.0/rocketmq-all-4.2.0-source-release.zip</a> 下载 4.2.0 的源码版本，执行以下命令来解压4.2.0源码版本并构建二进制文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unzip rocketmq-all-4.2.0-source-release.zip</span><br><span class="line"></span><br><span class="line">cd rocketmq-all-4.2.0/</span><br><span class="line"></span><br><span class="line">mvn -Prelease-all -DskipTests clean install -U</span><br></pre></td></tr></table></figure><p>构建成功如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fo7ukit9wbj31kw14o7l8.jpg" alt="2018-02-07_14-04-25"></p><p>进入到目录 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd distribution/target/apache-rocketmq</span><br></pre></td></tr></table></figure><h3 id="启动-NameServer"><a href="#启动-NameServer" class="headerlink" title="启动 NameServer"></a>启动 NameServer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line"></span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure><p>结果如下就代表启动成功了：</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fo5pxzbap2j31kw0h413p.jpg" alt="rocketmq01"></p><h3 id="启动-Broker"><a href="#启动-Broker" class="headerlink" title="启动 Broker"></a>启动 Broker</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line"></span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure><p>结果如下就代表启动成功了：从日志中可以看到 broker 注册到了 nameserver 上了（localhost:9876）</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fo5pxt2wavj31kw0jeqi0.jpg" alt="rocketmq02"></p><h3 id="发送和接收消息"><a href="#发送和接收消息" class="headerlink" title="发送和接收消息"></a>发送和接收消息</h3><p>在发送/接收消息之前，我们需要告诉客户名称服务器的位置。RocketMQ 提供了多种方法来实现这一点。为了简单起见，我们使用环境变量<code>NAMESRV_ADDR</code></p><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export NAMESRV_ADDR=localhost:9876</span><br><span class="line"></span><br><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br></pre></td></tr></table></figure><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo5py0e7lgj31kw0d47j2.jpg" alt="rocketmq03"></p><h4 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fo5pxwox08j31kw0rib29.jpg" alt="rocketmq04"></p><h3 id="关闭服务器"><a href="#关闭服务器" class="headerlink" title="关闭服务器"></a>关闭服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh bin/mqshutdown broker//停止 broker</span><br><span class="line"></span><br><span class="line">sh bin/mqshutdown namesrv//停止 nameserver</span><br></pre></td></tr></table></figure><p> 关闭成功后如下：</p><p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fo5pxsgyywj31kw0b5dov.jpg" alt="rocketmq05"></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>上面几个启动和关闭 name server 和 broker 的就不再说了，</p><ul><li>查看集群情况  <code>./mqadmin clusterList -n 127.0.0.1:9876</code></li><li>查看 broker 状态   <code>./mqadmin brokerStatus -n 127.0.0.1:9876 -b 172.20.1.138:10911</code>   (注意换成你的 broker 地址)</li><li>查看 topic 列表    <code>./mqadmin topicList -n 127.0.0.1:9876</code></li><li>查看 topic 状态    <code>./mqadmin topicStatus -n 127.0.0.1:9876 -t  MyTopic</code>  (换成你想查询的 topic)</li><li>查看 topic 路由    <code>./mqadmin topicRoute  -n 127.0.0.1:9876 -t  MyTopic</code></li></ul><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文是 RocketMQ 的安装及快速入门案例。</p><p>转发请注明地址：<a href="http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/06/RocketMQ-install/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fo5pxy3w8oj31hc0u0b29.jpg&quot; alt=&quot;tree-3097419_1920&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你对 RocketMQ 还没了解，建议先看下上一篇文章：&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RocketMQ 初探&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ 初探</title>
    <link href="http://yoursite.com/2018/02/05/RocketMQ/"/>
    <id>http://yoursite.com/2018/02/05/RocketMQ/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-03-06T16:18:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo4vbrj17mj31hc0zj7hb.jpg" alt="gooafoss-1840758_1920"></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>RocketMQ 是阿里开源的消息中间件，前不久捐献给了 Apache 。正如<a href="http://rocketmq.apache.org/" target="_blank" rel="noopener">官网</a>介绍如下：它是一个开源的分布式消息传递和流式数据平台。</p><a id="more"></a><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo4vbtu01lj31kw0jbjzw.jpg" alt="rocketmq01"></p><p>特点如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fo4vbvbgisj31kw0yw7c9.jpg" alt="rocketmq02"></p><h3 id="产品发展历史"><a href="#产品发展历史" class="headerlink" title="产品发展历史"></a>产品发展历史</h3><p>大约经历了三个主要版本迭代</p><p><strong>一、Metaq（Metamorphosis）1.x</strong></p><p>由开源社区killme2008维护，开源社区非常活跃。</p><p><strong>二、Metaq 2.x</strong></p><p>于2012年10月份上线，在淘宝内部被广泛使用。</p><p><strong>三、RocketMQ 3.x</strong></p><p>基于公司内部开源共建原则，RocketMQ 项目只维护核心功能，且去除了所有其他运行时依赖，核心功能最简化。每个 BU 的个性化需求都在 RocketMQ 项目之上进行深度定制。RocketMQ 向其他 BU 提供的仅仅是 Jar 包，例如要定制一个 Broker，那么只需要依赖 rocketmq-broker 这个 jar 包即可，可通过 API 进行交互，如果定制 client，则依赖 rocketmq-client 这个 jar 包，对其提供的 api 进行再封装。</p><p>在 RocketMQ 项目基础上衍生的项目如下</p><ul><li><p>com.taobao.metaq v3.0 = RocketMQ + 淘宝个性化需求</p><p>为<strong>淘宝</strong>应用提供消息服务</p></li><li><p>com.alipay.zpullmsg v1.0 =RocketMQ + 支付宝个性化需求</p><p>为<strong>支付宝</strong>应用提供消息服务</p></li><li><p>com.alibaba.commonmq v1.0 = Notify + RocketMQ + B2B个性化需求</p><p>为 <strong>B2B</strong> 应用提供消息服务</p></li></ul><p><strong>四、RocketMQ 3.x</strong></p><p>目前它的最新版本是 4.2 版本。</p><h3 id="概念专业术语"><a href="#概念专业术语" class="headerlink" title="概念专业术语"></a>概念专业术语</h3><p><strong>Producer</strong></p><p>消息生产者，负责产生消息，一般由业务系统负责产生消息。</p><p><strong>Consumer</strong></p><p>消息消费者，负责消费消息，一般是后台系统负责异步消费。</p><p><strong>Push Consumer</strong></p><p>Consumer 的一种，应用通常向 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调 Listener 接口方法。</p><p><strong>Pull Consumer</strong></p><p>Consumer 的一种，应用通常主动调用 Consumer 的拉消息方法从 Broker 拉消息，主动权由应用控制。</p><p><strong>Producer Group</strong></p><p>一类 Producer 的集合名称，这类 Producer 通常发送一类消息，且发送逻辑一致。</p><p><strong>Consumer Group</strong></p><p>一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。</p><p><strong>Broker</strong></p><p>消息中转角色，负责存储消息，转发消息，一般也称为 Server。在 JMS 规范中称为 Provider。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fo4vbs0dn7j30r30c23zl.jpg" alt="rmq-basic-arc"></p><p>从这架构图中可以看到它主要由四部分组成：Producer（生产者）、NameServer、Broker、Consumer（消费者）。</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>生产者支持分布式部署。分布式生产者通过多种负载均衡模式向 Broker 集群发送消息。发送过程支持快速失败并具有低延迟。</p><h4 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h4><p>它提供轻量级服务发现和路由，每个 Name Server 记录完整的路由信息，提供相应的读写服务，支持快速存储扩展。主要包括两个功能：</p><ul><li>代理管理，  <strong>NameServer</strong> 接受来自 Broker 集群的注册，并提供检测代理是否存在的心跳机制。</li><li>路由管理，每个 NameServer 将保存有关代理群集的全部路由信息以及客户端查询的<strong>队列</strong>信息。</li></ul><p>我们知道，RocketMQ客户端（生产者/消费者）将从NameServer查询队列路由信息，但客户端如何找到NameServer地址？</p><p>将NameServer地址列表提供给客户端有四种方法：</p><ul><li>编程方式，就像<code>producer.setNamesrvAddr(&quot;ip:port&quot;)</code>。</li><li>Java选项，使用<code>rocketmq.namesrv.addr</code>。</li><li>环境变量，使用<code>NAMESRV_ADDR</code>。</li><li>HTTP 端点。</li></ul><h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p>Broker 通过提供轻量级的 Topic 和 Queue 机制来照顾消息存储。它们支持 Push 和 Pull 模式，包含容错机制（2个拷贝或者3个拷贝），并且提供了强大的峰值填充和以原始时间顺序累计数千亿条消息的能力。此外，broker 还提供灾难恢复，丰富的指标统计数据和警报机制，而传统的消息传递系统都缺乏这些机制。</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fo4vbpoxtej30r30dsdgs.jpg" alt="rmq-basic-component"></p><p>如上图：Broker 服务器重要的子模块：</p><ul><li>远程处理模块是 broker 的入口，处理来自客户的请求。</li><li>Client manager，管理客户（生产者/消费者）并维护消费者的主题订阅。</li><li>Store Service，提供简单的 API 来存储或查询物理磁盘中的消息。</li><li>HA 服务，提供主代理和从代理之间的数据同步功能。</li><li>索引服务，通过指定键为消息建立索引，并提供快速的消息查询。</li></ul><h4 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h4><p>消费者也支持 Push 和 Pull 模型中的分布式部署。它还支持群集消费和消息广播。它提供了实时的消息订阅机制，可以满足大多数消费者的需求。</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文是对 RocketMQ 的简单点了解，参考了官网介绍。</p><p>转载请注明地址：<a href="http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/02/05/RocketMQ/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcgy1fo4vbrj17mj31hc0zj7hb.jpg&quot; alt=&quot;gooafoss-1840758_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;RocketMQ 是阿里开源的消息中间件，前不久捐献给了 Apache 。正如&lt;a href=&quot;http://rocketmq.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官网&lt;/a&gt;介绍如下：它是一个开源的分布式消息传递和流式数据平台。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RocketMQ" scheme="http://yoursite.com/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot RabbitMQ 整合进阶版</title>
    <link href="http://yoursite.com/2018/01/28/RabbitMQ/"/>
    <id>http://yoursite.com/2018/01/28/RabbitMQ/</id>
    <published>2018-01-27T16:00:00.000Z</published>
    <updated>2018-03-06T16:17:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fnu3cojj9rj31hc0u079o.jpg" alt="sea-2561397_1920"></p><h3 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h3><p>RabbitMQ 是消息中间件的一种, 消息中间件即分布式系统中完成消息的发送和接收的基础软件. 这些软件有很多, 包括 ActiveMQ ( apache 公司的), RocketMQ (阿里巴巴公司的, 现已经转让给 apache), 还有性能极高的 Kafka。</p><a id="more"></a><p>消息中间件的工作过程可以用<strong>生产者消费者模型</strong>来表示. 即生产者不断的向消息队列发送信息, 而消费者从消息队列中消费信息. 具体过程如下:</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fnuk4o5optj30pz07xdg7.jpg" alt="972319-20170311160512014-1914425149"></p><p>从上图可看出, 对于消息队列来说, 生产者,消息队列,消费者 是最重要的三个概念。生产者发消息到消息队列中去,  消费者监听指定的消息队列, 并且当消息队列收到消息之后, 接收消息队列传来的消息, 并且给予相应的处理. 消息队列常用于分布式系统之间互相信息的传递.</p><h3 id="RabbitMQ-工作原理"><a href="#RabbitMQ-工作原理" class="headerlink" title="RabbitMQ 工作原理"></a>RabbitMQ 工作原理</h3><p>对于 RabbitMQ 来说, 除了这三个基本模块以外, 还添加了一个模块, 即交换机(Exchange). 它使得生产者和消息队列之间产生了隔离, 生产者将消息发送给交换机,而交换机则根据调度策略把相应的消息转发给对应的消息队列. 那么 RabitMQ 的工作流程如下所示:</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fnuk4ohjbmj30dd08zjrw.jpg" alt="972319-20170311161512951-1006030113"></p><p>说一下交换机: 交换机的主要作用是接收相应的消息并且绑定到指定的队列. 交换机有四种类型, 分别为Direct, topic, headers, Fanout.</p><p>Direct 是 RabbitMQ 默认的交换机模式,也是最简单的模式.即创建消息队列的时候,指定一个 BindingKey. 当发送者发送消息的时候, 指定对应的 Key. 当 Key 和消息队列的 BindingKey 一致的时候,消息将会被发送到该消息队列中.</p><p>topic 转发信息主要是依据通配符, 队列和交换机的绑定主要是依据一种模式(通配符+字符串), 而当发送消息的时候, 只有指定的 Key 和该模式相匹配的时候, 消息才会被发送到该消息队列中.</p><p>headers 也是根据一个规则进行匹配, 在消息队列和交换机绑定的时候会指定一组键值对规则, 而发送消息的时候也会指定一组键值对规则, 当两组键值对规则相匹配的时候, 消息会被发送到匹配的消息队列中.</p><p>Fanout 是路由广播的形式, 将会把消息发给绑定它的全部队列, 即便设置了 key, 也会被忽略.</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/01/28/RabbitMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/28/RabbitMQ/</a></p><h3 id="SpringBoot-整合-RabbitMQ（Topic-转发模式）"><a href="#SpringBoot-整合-RabbitMQ（Topic-转发模式）" class="headerlink" title="SpringBoot 整合 RabbitMQ（Topic 转发模式）"></a>SpringBoot 整合 RabbitMQ（Topic 转发模式）</h3><p>在上一篇文章中，我们也将 SpringBoot 和 RabbitMQ 整合过，不过那是使用 Direct 模式，文章地址是：<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合使用</a></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">SpringBoot Kafka 整合使用</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合使用</a></p><p>3、<a href="http://www.54tianzhisheng.cn/2018/01/27/SpringBoot-ActiveMQ/" target="_blank" rel="noopener">SpringBoot ActiveMQ 整合使用</a></p><p>4、<a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/" target="_blank" rel="noopener">Kafka 安装及快速入门</a></p><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>接下来，我要带大家继续整合（Topic 转发模式）：</p><p>1、配置文件和 pom.xml 这些还都是一样的，我们不用再修改</p><p>2、启动类中创建 Queue 和 Exchange，并把 Queue 按照相应的规则绑定到交换机Queue 上。代码如下图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"rpc-queue-zhisheng"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TopicExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> TopicExchange(<span class="string">"rpc-exchange-zhisheng"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">(Queue queue, TopicExchange exchange)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">"rpc-zhisheng"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建一个 Queue 和 Exchange ，然后绑定。</p><p>注意：上面代码中的 with(“rpc-zhisheng”)  这个 “zhisheng” 是 routingkey，RabbitMQ 将会根据这个参数去寻找有没有匹配此规则的队列，如果有，则会把消息发送给它，如果不止有一个，则会把消息分发给所有匹配的队列。</p><p>3、消息发送类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.TopicExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TopicExchange exchange;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(exchange.getName(), <span class="string">"rpc-zhisheng"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是发送消息的代码，“rpc-zhisheng” 就是上面我们设置的 routingkey。</p><p>4、消息接收端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"rpc-queue-zhisheng"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------receive ------- "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、启动类中注入 发送消息类，然后调用 send 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitMQClient client;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">  stopWatch.start();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  client.send(<span class="string">"  zhisheng, ---------  send "</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">  stopWatch.stop();</span><br><span class="line">  System.out.println(<span class="string">"总共耗时："</span> +      stopWatch.getTotalTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行此 SpringBoot 项目，则可以发现结果如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fnu3cn8zwjj31kw0y9kfi.jpg" alt="Snip20180126_2"></p><p>这里测试的是匹配一个消息队列的情况，感兴趣的可以测试下匹配多个消息队列的。</p><h3 id="SpringBoot-整合-RabbitMQ-Fanout-Exchange-形式"><a href="#SpringBoot-整合-RabbitMQ-Fanout-Exchange-形式" class="headerlink" title="SpringBoot 整合 RabbitMQ( Fanout Exchange 形式)"></a>SpringBoot 整合 RabbitMQ( Fanout Exchange 形式)</h3><p>Fanout Exchange 形式又叫广播形式。</p><p>任何发送到 Fanout Exchange 的消息都会被转发到与该 Exchange 绑定(Binding)的所有 Queue 上。</p><ul><li>这种模式需要提前将 Exchange 与 Queue 进行绑定，一个 Exchange 可以绑定多个 Queue，一个 Queue 可以同多个 Exchange 进行绑定</li><li>这种模式不需要 RoutingKey</li><li>如果接受到消息的 Exchange 没有与任何 Queue 绑定，则消息会被抛弃。</li></ul><p>1、消息发送类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"fanout-exchange"</span>, <span class="string">""</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以不设置 routingkey 了。</p><p>2、启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhisheng.rabbitmq.rpc.client.RabbitMQClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.FanoutExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqRpcApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitMQClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client.send2(<span class="string">"zhisheng ++++++++++ send2 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(RabbitmqRpcApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"rpc.queue"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"queue2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"rpc.queue2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"queue3"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">queue3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">"rpc.queue3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FanoutExchange <span class="title">exchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FanoutExchange(<span class="string">"fanout-exchange"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding</span><span class="params">(@Qualifier(<span class="string">"queue"</span>)</span> Queue queue, FanoutExchange exchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding2</span><span class="params">(@Qualifier(<span class="string">"queue2"</span>)</span> Queue queue, FanoutExchange exchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">binding3</span><span class="params">(@Qualifier(<span class="string">"queue3"</span>)</span> Queue queue, FanoutExchange exchange) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Jackson2JsonMessageConverter <span class="title">messageConverter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动类中我创建三个 Queue： <code>rpc.queue</code>,  <code>rpc.queue2</code> , <code>rpc.queue3</code></p><p>也创建一个 FanoutExchange，并把这三个 Queue 绑定在同一个交换机 <code>fanout-exchange</code> 上面</p><p>注意：这个 <code>fanout-exchange</code> 交换机不知为啥，我自己在应用程序里创建，运行程序会出错，下面讲讲我是怎么解决的。</p><p>我是从 RabbitMQ 管理界面直接添加个 exchange 的。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fnu3co30lkj31hy1bun4z.jpg" alt="Snip20180126_3"></p><p>3、消息接收类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.rpc.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"rpc.queue"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------receive ------- "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"rpc.queue2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive2</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------receive2 ------- "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"rpc.queue3"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive3</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------receive3 ------- "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听每个 Queue，并有一个方法输出对应接收到的消息。</p><p>4、运行项目</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fnu3cmf22dj31kw0zoh6u.jpg" alt="Snip20180126_4"></p><p>结果如上，每个队列都打印出自己收到的结果，同时我们看看这三个 Queue 是不是绑定到 Exchange 上呢？</p><p>可以看到三个 Queue 都绑定在 Exchange 上了。</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fnu3clys6lj31kw1ajjy9.jpg" alt="Snip20180126_5"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>RabbitMQ 与 SpringBoot 整合就到这里为止了，后面如果有时间会深度研究 RabbitMQ 的。</p><p>还请继续关注我的博客：<a href="http://www.54tianzhisheng.cn/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tNc79ly1fnu3cojj9rj31hc0u079o.jpg&quot; alt=&quot;sea-2561397_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;消息中间件&quot;&gt;&lt;a href=&quot;#消息中间件&quot; class=&quot;headerlink&quot; title=&quot;消息中间件&quot;&gt;&lt;/a&gt;消息中间件&lt;/h3&gt;&lt;p&gt;RabbitMQ 是消息中间件的一种, 消息中间件即分布式系统中完成消息的发送和接收的基础软件. 这些软件有很多, 包括 ActiveMQ ( apache 公司的), RocketMQ (阿里巴巴公司的, 现已经转让给 apache), 还有性能极高的 Kafka。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot ActiveMQ 整合使用</title>
    <link href="http://yoursite.com/2018/01/27/SpringBoot-ActiveMQ/"/>
    <id>http://yoursite.com/2018/01/27/SpringBoot-ActiveMQ/</id>
    <published>2018-01-26T16:00:00.000Z</published>
    <updated>2018-03-06T16:19:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fns53btbl0j31hc0zldyz.jpg" alt="busan-night-scene-1747130_1920"></p><h3 id="介绍-ActiveMQ"><a href="#介绍-ActiveMQ" class="headerlink" title="介绍 ActiveMQ"></a>介绍 ActiveMQ</h3><p>它是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ  是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的J2EE应用中间仍然扮演着特殊的地位。—— 摘自百度百科，偷了个懒。</p><a id="more"></a><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p>1、<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">SpringBoot Kafka 整合使用</a></p><p>2、<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">SpringBoot RabbitMQ 整合使用</a></p><h3 id="安装-ActiveMQ"><a href="#安装-ActiveMQ" class="headerlink" title="安装 ActiveMQ"></a>安装 ActiveMQ</h3><p>同之前一样，直接在 Docker 里面玩吧。命令也是一行解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8161:8161 -p 61616:61616 -e ACTIVEMQ_ADMIN_LOGIN=admin -e ACTIVEMQ_ADMIN_PASSWORD=admin --name activemq webcenter/activemq</span><br></pre></td></tr></table></figure><p>简单解释下：</p><ul><li>8186: 表示 ActiveMQ 控制台端口号，它和 RabbitMQ 一样都是有控制台的，可以登陆控制台进行操作的</li><li>61616 ： 表示 ActiveMQ 所监听的 TCP 端口号，应用程序可通过该端口号与 ActiveMQ 建立 TCP 连接</li><li>CTIVEMQ_ADMIN_LOGIN ：登陆控制台的用户名</li><li>ACTIVEMQ_ADMIN_PASSWORD ：登陆控制台的密码</li></ul><p>执行后，可在浏览器输入 <a href="http://localhost:8161/" target="_blank" rel="noopener">http://localhost:8161/</a>   查看控制台，</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fns4zm1yqfj31kw0djn3k.jpg" alt="Snip20180124_1"></p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fns4zmk78ej31kw0ladq0.jpg" alt="Snip20180124_2"></p><p>解释下上面图片中控制台这些按钮的基本信息：</p><ul><li>Home：查看 ActiveMQ 的常见信息</li><li>Queues：查看 ActiveMQ 的队列信息</li><li>Topics：查看 ActiveMQ 的主题信息</li><li>Subscribers：查看主题的订阅者信息</li><li>Connections：查看 ActiveMQ 客户端的连接信息</li><li>Network：查看 ActiveMQ 的网络信息</li><li>Scheduled：查看 ActiveMQ 的定时任务</li><li>Send：用于通过表单方式向队列或者主题发送具体的消息</li></ul><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>IDEA 创建 SpringBoot 项目，因为 SpringBoot 已经内置了对 ActiveMQ 的支持，所以直接引入依赖 <code>spring-boot-starter-activemq</code> 就行。整体项目结构如下：</p><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fns4zkpkhvj30os0tkwg8.jpg" alt="Snip20180124_3"></p><p>1、<strong>pom.xml 文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zhisheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>activemq<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot ActiveMQ<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、<strong>配置文件</strong>  application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.activemq.broker-url=tcp://localhost:61616</span><br><span class="line">spring.activemq.user=admin</span><br><span class="line">spring.activemq.password=admin</span><br></pre></td></tr></table></figure><p>3、<strong>发送消息类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.activemq.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.core.JmsTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMQClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsTemplate jmsTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        jmsTemplate.convertAndSend(<span class="string">"zhisheng"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，和 RabbitMQ 类似，不多说了。</p><p>4、<strong>消息接收类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.activemq.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.jms.annotation.JmsListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActiveMQServer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JmsListener</span>(destination = <span class="string">"zhisheng"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的 message 是："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、<strong>注意</strong></p><p>这个队列是不需要我们提前定义好的，它和 RabbitMQ 不一样，它会在我们需要的时候动态的创建。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.activemq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zhisheng.activemq.client.ActiveMQClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StopWatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivemqApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    ActiveMQClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            client.send(<span class="string">"发送消息----zhisheng-----"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(<span class="string">"发送消息耗时: "</span> + stopWatch.getTotalTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ActivemqApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送一万条消息运行后需要的时间挺久的：73180 ms</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fns4zlmbg7j31kw0wutop.jpg" alt="Snip20180124_4"></p><p>比 RabbitMQ 发送 10000 条消息耗时 215 ms 不知道高出多少倍了，可见其性能并不高的。</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/01/27/SpringBoot-ActiveMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/27/SpringBoot-ActiveMQ/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcly1fns53btbl0j31hc0zldyz.jpg&quot; alt=&quot;busan-night-scene-1747130_1920&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍-ActiveMQ&quot;&gt;&lt;a href=&quot;#介绍-ActiveMQ&quot; class=&quot;headerlink&quot; title=&quot;介绍 ActiveMQ&quot;&gt;&lt;/a&gt;介绍 ActiveMQ&lt;/h3&gt;&lt;p&gt;它是 Apache 出品，最流行的，能力强劲的开源消息总线。ActiveMQ  是一个完全支持 JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现，尽管 JMS 规范出台已经是很久的事情了，但是 JMS 在当今的J2EE应用中间仍然扮演着特殊的地位。—— 摘自百度百科，偷了个懒。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
      <category term="ActiveMQ" scheme="http://yoursite.com/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot  RabbitMQ 整合使用</title>
    <link href="http://yoursite.com/2018/01/26/SpringBoot-RabbitMQ/"/>
    <id>http://yoursite.com/2018/01/26/SpringBoot-RabbitMQ/</id>
    <published>2018-01-25T16:00:00.000Z</published>
    <updated>2018-03-06T16:20:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/6DFKcmCgC7.png-1" alt="mark"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>上次写了篇文章，<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">《SpringBoot Kafka 整合使用》</a>，阅读量还挺高的，于是想想还是把其他几种 MQ 也和 SpringBoot 整合使用下。</p><a id="more"></a><p>下面是四种比较流行的 MQ ：</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fnrqdwnlsej30fw07274m.jpg" alt="rabbitmq-1"></p><p>后面都写写和 SpringBoot 整合的文章。</p><h3 id="安装-RabbitMQ"><a href="#安装-RabbitMQ" class="headerlink" title="安装 RabbitMQ"></a>安装 RabbitMQ</h3><p>由于换 Mac 了，所以一些环境就直接在 Mac 搞，但是像安装 RabbitMQ 这些又会把自己电脑系统给搞的太乱，所以能在 Docker 里面安装就安装在 Docker，这次 RabbitMQ 我也直接在 Docker 里安装。</p><p>启动 Docker for Mac，如果没安装过的请看我上一篇文章：<a href="http://www.54tianzhisheng.cn/2018/01/25/Docker-install/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/25/Docker-install/</a></p><p>当然你也可以在自己的 Linux 服务器或者虚拟机里启动安装 RabbitMQ 。</p><p>Docker 安装的话很简单，因为 RabbitMQ 官方已经提供了自己的 Docker 容器，只需要一行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d  -p 15672:15672  -p  5672:5672  -e RABBITMQ_DEFAULT_USER=admin -e RABBITMQ_DEFAULT_PASS=admin --name rabbitmq rabbitmq:3-management</span><br></pre></td></tr></table></figure><p>该镜像拥有一个基于 web 的控制台和 Http API。Http API 可以在地址看到如何使用：<code>http://localhost:15672/api/</code></p><p>讲解下上面命令行：</p><ul><li>15672 ：表示 RabbitMQ 控制台端口号，可以在浏览器中通过控制台来执行 RabbitMQ 的相关操作。</li><li>5672 : 表示 RabbitMQ 所监听的 TCP 端口号，应用程序可通过该端口与 RabbitMQ 建立 TCP 连接，并完成后续的异步消息通信</li><li>RABBITMQ_DEFAULT_USER：用于设置登陆控制台的用户名，这里我设置 admin</li><li>RABBITMQ_DEFAULT_PASS：用于设置登陆控制台的密码，这里我设置 admin</li></ul><p>容器启动成功后，可以在浏览器输入地址：<a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a>  访问控制台</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqdzkxzoj30js0980t7.jpg" alt="rabbitmq-2"></p><p>登陆后：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqohaja0j31kw0vr0z3.jpg" alt="rabbitmq-3"></p><p>简单描述下上图中中控制台的列表的作用：</p><ul><li>Overview ：用于查看 RabbitMQ 的一些基本信息（消息队列、消息发送速率、节点、端口和上下文信息等）</li><li>Connections：用于查看 RabbitMQ 客户端的连接信息</li><li>Channels：用户查看 RabbitMQ 的通道信息</li><li>Exchange：用于查看 RabbitMQ 交换机</li><li>Queues：用于查看 RabbitMQ 的队列</li><li>Admin：用于管理用户，可增加用户</li></ul><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在 IDEA 中创建一个 SpringBoot 项目结构：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqp4fi3cj30pk12qtcc.jpg" alt="Snip20180124_5"></p><p>SpringBoot 框架中已经内置了对 RabbitMQ 的支持，如果你看过官方文档的话，就可以看到的，我们需要把依赖 spring-boot-starter-amqp 引入就行。</p><p>1、 <strong>pom.xml</strong> 引入依赖后如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zhisheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rabbitmq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>rabbitmq<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot RabbitMQ<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、<strong>application.properties</strong>  配置修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.rabbitmq.addresses=localhost:5672</span><br><span class="line">spring.rabbitmq.username=admin</span><br><span class="line">spring.rabbitmq.password=admin</span><br></pre></td></tr></table></figure><p>3、<strong>消息发送类</strong> RabbitMQClient.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.client;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"zhisheng"</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，发送消息代码就实现了。</p><p>这里关键的代码为 rabbitTemplate.convertAndSend() 方法，<code>zhisheng</code> 这个是路由规则（routingKey），它的值表明将消息发送到指定的队列 <code>zhisheng</code> 中去，这里跟了下源码，发现 convertAndSend() 方法最后调用的方法其实是一个 doSend() 方法。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fnrqpy395kj31kw0wkn75.jpg" alt="Snip20180124_7"></p><p>4、<strong>消息接收类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhisheng.rabbitmq.server;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by zhisheng_tian on 2018/1/23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitListener</span>(queues = <span class="string">"zhisheng"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"收到的 message 是："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你看，这里就有个 <code>RabbitListener</code> 一直在监听着队列 <code>zhisheng</code> 。</p><p>当然这个队列是必须要我们自己在应用程序中创建好，它不会像我之前写的文章 <a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">《SpringBoot Kafka 整合使用》</a>  中的 Kafka 一样，Kafka 它会在用到队列的时候动态的创建，不需要我们提前创建好。</p><p>那么在 RabbitMQ 中该如何创建队列呢？</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqqcykkoj31kw0roajh.jpg" alt="Snip20180124_8"></p><p>如上图所示：这样我们就创建好了一个 <code>zhisheng</code> 的队列，当程序开始运行时，消息接收类会持续监听队列 <code>zhisheng</code> 中即将到来的消息。</p><p>5、<strong>运行项目</strong></p><p>需要在启动类中注入发送消息的类，并且提供 init 方法，在 init 方法中调用发送消息类的 send()  方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">rabbitMQClient.send(<span class="string">"发送消息----zhisheng-----"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：init() 方法带有 @PostConstruct 注解，被 @PostConstruct 修饰的方法会在构造函数之后执行。</p><p>启动项目就可以发现控制台已经接收到消息了。</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fnrqqqr9zlj31kw10qdv6.jpg" alt="Snip20180124_9"></p><p>6、<strong>单线程测试性能</strong></p><p>看到上面图片中注释掉的代码没？那就是用来测试消息发送的性能的，我发送 10000 条消息看看总共耗时多少。</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fnrqr3c0wnj31kw0tctgm.jpg" alt="Snip20180124_10"></p><p>10000 条消息发送耗时：215ms。   这是在单线程下，下次可以和其他的 MQ 测试对比下，并且也可以在多线程的环境下测试性能。</p><p>同时从控制台可以看到发送的速率：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fnrqrd94g6j31kw0s1tim.jpg" alt="Snip20180124_11"></p><p>7、<strong>多线程测试性能</strong></p><p>开了10 个线程，每个线程发送 10000 条消息。</p><p>init  方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">        stopWatch.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> threads = <span class="number">10</span>;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(threads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(threads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threads; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    start.await();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">10000</span>; i1++) &#123;</span><br><span class="line">                        rabbitMQClient.send(<span class="string">"发送消息----zhisheng-----"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    end.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        start.countDown();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            end.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        System.out.println(<span class="string">"发送消息耗时："</span> + stopWatch.getTotalTimeMillis());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>耗时：4063ms</p><p>控制台显示如下图：</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fnrqrt6ngfj31kw0ul47b.jpg" alt="Snip20180124_12"></p><p>8、<strong>注意</strong></p><p>这里测试发送的消息直接是 String 类型的，你也可以测试下 Bean 类，这需要注意需要序列化。</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/26/SpringBoot-RabbitMQ/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180107/6DFKcmCgC7.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;上次写了篇文章，&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《SpringBoot Kafka 整合使用》&lt;/a&gt;，阅读量还挺高的，于是想想还是把其他几种 MQ 也和 SpringBoot 整合使用下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Mac 安装 Docker 及常用命令</title>
    <link href="http://yoursite.com/2018/01/25/Docker-install/"/>
    <id>http://yoursite.com/2018/01/25/Docker-install/</id>
    <published>2018-01-24T16:00:00.000Z</published>
    <updated>2018-03-06T16:09:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/mALkf4CKA2.png-1" alt="mark"></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>微服务 + 容器，完美的一对！必须得好好学习学习。</p><a id="more"></a><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>Mac 下 Docker 的安装真心建议跟着官方的文档走一遍，官网已经讲的很详细了。</p><p><a href="https://docs.docker.com/docker-for-mac/install/#what-to-know-before-you-install" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/install/#what-to-know-before-you-install</a></p><h3 id="使用-Docker-for-Mac"><a href="#使用-Docker-for-Mac" class="headerlink" title="使用 Docker for Mac"></a>使用 Docker for Mac</h3><p><a href="https://docs.docker.com/docker-for-mac/#check-versions-of-docker-engine-compose-and-machine" target="_blank" rel="noopener">https://docs.docker.com/docker-for-mac/#check-versions-of-docker-engine-compose-and-machine</a></p><h3 id="配置-Docker-加速器"><a href="#配置-Docker-加速器" class="headerlink" title="配置 Docker 加速器"></a>配置 Docker 加速器</h3><p>Docker 加速器是什么，我需要使用吗？</p><p>使用 Docker 的时候，需要经常从官方获取镜像，但是由于显而易见的网络原因，拉取镜像的过程非常耗时，严重影响使用 Docker 的体验。因此 DaoCloud 推出了加速器工具解决这个难题，通过智能路由和缓存机制，极大提升了国内网络访问 Docker Hub 的速度，目前已经拥有了广泛的用户群体，并得到了 Docker 官方的大力推荐。如果您是在国内的网络环境使用 Docker，那么 Docker 加速器一定能帮助到您。</p><p>注册 <a href="">daocloud</a>，然后在 mac 标签页复制加速器 url。</p><p><img src="https://upload-images.jianshu.io/upload_images/5225109-54fdf15443d355fd.png?imageMogr2/auto-orient/" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/5225109-8dd1076f952fda33.png?imageMogr2/auto-orient/" alt=""></p><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><p>跟着下面的文章进行敲一遍，熟悉下 Docker 整个的使用。</p><p><a href="https://www.jianshu.com/p/cf6e7248b6c7" target="_blank" rel="noopener">https://www.jianshu.com/p/cf6e7248b6c7</a></p><h3 id="Docker-常用命令"><a href="#Docker-常用命令" class="headerlink" title="Docker 常用命令"></a>Docker 常用命令</h3><p>下面列出些自己常用的命令，目的就是记录下来，以后忘记了，再拿来跟着敲就行！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t &lt;image_name/continar_id&gt; /bin/bash  启动容器并启动bash（交互方式）</span><br><span class="line"></span><br><span class="line">docker run -d -it  image_name   启动容器以后台方式运行(更通用的方式）</span><br><span class="line"></span><br><span class="line">docker ps   列出当前所有正在运行的container</span><br><span class="line"></span><br><span class="line">docker ps -a  列出所有的container</span><br><span class="line"></span><br><span class="line">docker ps -l   列出最近一次启动的container</span><br><span class="line"></span><br><span class="line">docker images  列出本地所有的镜像</span><br><span class="line"></span><br><span class="line">docker rmi imagesID   删除指定的镜像id</span><br><span class="line"></span><br><span class="line">docker rm CONTAINER ID   删除指定的CONTAINER id</span><br><span class="line"></span><br><span class="line">docker diff 镜像名    查看容器的修改部分</span><br><span class="line"></span><br><span class="line">docker kill CONTAINER ID   杀掉正在运行的容器</span><br><span class="line"></span><br><span class="line">docker logs 容器ID/name   可以查看到容器主程序的输出</span><br><span class="line"></span><br><span class="line">docker pull image_name    下载image</span><br><span class="line"></span><br><span class="line">docker push image_name   发布docker镜像</span><br><span class="line"></span><br><span class="line">docker version   查看docker版本</span><br><span class="line"></span><br><span class="line">docker info   查看docker系统的信息</span><br><span class="line"></span><br><span class="line">docker inspect 容器的id 可以查看更详细的关于某一个容器的信息</span><br><span class="line"></span><br><span class="line">docker run -d  image-name   后台运行镜像</span><br><span class="line"></span><br><span class="line">docker search 镜像名    查找公共的可用镜像</span><br><span class="line"></span><br><span class="line">docker stop 容器名/容器 ID      终止运行的容器</span><br><span class="line"></span><br><span class="line">docker restart 容器名/容器 ID    重启容器</span><br><span class="line"></span><br><span class="line">docker commit  提交，创建个新镜像</span><br><span class="line"></span><br><span class="line">docker build [OPTIONS] PATH | URL | -   利用 Dockerfile 创建新镜像</span><br></pre></td></tr></table></figure><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请注明地址：<a href="http://www.54tianzhisheng.cn/2018/01/25/Docker-install/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/25/Docker-install/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180107/mALkf4CKA2.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;微服务 + 容器，完美的一对！必须得好好学习学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>MacBook Pro 初体验</title>
    <link href="http://yoursite.com/2018/01/24/mac/"/>
    <id>http://yoursite.com/2018/01/24/mac/</id>
    <published>2018-01-23T16:00:00.000Z</published>
    <updated>2018-03-06T16:15:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/kFhlh5gA23.png-1" alt="mark"></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><a id="more"></a><p>在 Mac 到手之前就在各种群里看到人说 Mac 多好用，也有很多人鼓吹过 Mac 的好处，最后也坚定我的年前目标了 —— 就是买台 Mac，之前请原谅我这个穷鬼，买不起，现在买了 Mac 后更加得体谅我这个穷鬼了，毕竟在上海这个城市，靠着实习工资买这种奢侈品，不容易啊😄 。废话不多说，如果愿意支持我的，请在文章底部扫描二维码，在此先谢谢了。</p><h3 id="如何挑选？"><a href="#如何挑选？" class="headerlink" title="如何挑选？"></a>如何挑选？</h3><p>MacBook 主要分两系列：MacBook Air 和 MacBook Pro。</p><p>Air 的话个人感觉配置不高，如果是开发还是建议买 Pro 系列的。如今买的话，可能还会分 2015 款、2016 款、2017 款。每款中又分 内存大小（8/16g）、硬盘大小（128/256/512g）、CPU、处理器（i5/i7）、是否有TouchBar、显卡等。不同配置对应电脑的型号也是不一样的。下面直接上一张在我的特殊渠道里的报价表截图吧。（想了解的可以找我）</p><p><img src="http://ohfk1r827.bkt.clouddn.com/mac-1.jpg-1" alt="mac-1"></p><p>光这型号，不懂的人还真不会挑。</p><p>不得不说，苹果电脑真尼玛难挑啊，如果你是土豪，那不用挑了，直接上最高价钱的吧。</p><p>然后可以从配置中发现 2016 款和 2017 款变化真心不大，在同等配置下，2017 款几乎比 2016 款价格高个 3000 来块。</p><p>然后就是 512 G 硬盘比 256 G 也几乎贵个 2000 多。</p><p>16G 那是必须的上啊，标配了，8G 就不说了，太小了。</p><p>含 TouchBar，虽然确实用处不大，不过调音两还是不错的。高配都有 TouchBar 的。</p><p>出于 <strong>qiong</strong> ，我买了 2016 款，配置是：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/mac-2.jpg-1" alt="mac-2"></p><p>不过现在 2016 款好像停产了。</p><h3 id="到手"><a href="#到手" class="headerlink" title="到手"></a>到手</h3><p>2018.01.11 下午六点快递送到的，很开心。晚上拿回家拆箱，第一件事情就是检查序列号啊，上面的图片打码掉的就是序列号，这个序列号在电脑机身、系统、外牛皮癣盒都有的，可以在官网查询这个序列号，获得电脑的激活日期和剩余保修时间的。再就是查询电脑的电池循环次数了，我的是一次，一般好像是几次之内都是符合的。证明之前没被别人用过，这个数字我也忘记了。</p><h3 id="熟悉系统"><a href="#熟悉系统" class="headerlink" title="熟悉系统"></a>熟悉系统</h3><p>Mac 系统是类 Unix 系统，其实我觉得到和 Ubuntu 系统挺像的，既有图形化界面，也可以命令行操作。熟悉过 Linux 的应该上手很快的。</p><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><p>可以在 Appstore 里面下载，也可以在一些软件的官网直接下载 mac 版的。安装也挺简单的。如果你不知道有什么软件可以安装，那么我这里给你份 Mac 软件参考列表：<a href="https://github.com/jaywcjlove/awesome-mac/blob/master/README-zh.md" target="_blank" rel="noopener">https://github.com/jaywcjlove/awesome-mac/blob/master/README-zh.md</a></p><p>当然了，上面的不一定全，具体用到其他的还是的自己去找对应的软件。</p><p>还有就是好多软件是收费的，在 Mac 上如果要下载的话，还的费点心思去破解，比如 Office、IDEA、Adobe 系列等，当然也不是鼓吹大家去破解，我们自己用用就行，虽说现在没钱支持，但是有钱的话还是支持下。我一个写博客的知道写博客的不容易，那写软件的更不容易了，能支持一两块也挺好的。</p><p>然后就是美化下我们的一些软件，比如我们的终端之类的、尽量使用 Homebrew 安装软件。当然这篇文章不会写这些的，改天专门写篇文章写这个话题。</p><p>还有就是在 Mac 上从新打造一个适合自己的新写作环境（软件、Hexo 写博客环境）。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>体验了 Mac 也有一个多礼拜了，整体效果还是不错的，毕竟花了巨资呢，也算是完成了自己年前的小目标。先 bb 到这里吧。有时间再写点关于 Mac 上的东西，这次写的比较简单，这篇文章也是在 Mac 上写的第一篇文章。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180107/kFhlh5gA23.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Mac" scheme="http://yoursite.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Admin 使用指南</title>
    <link href="http://yoursite.com/2018/01/17/SpringBoot-Admin/"/>
    <id>http://yoursite.com/2018/01/17/SpringBoot-Admin/</id>
    <published>2018-01-16T16:00:00.000Z</published>
    <updated>2018-03-06T16:20:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/m1b2jfCc9I.png-1" alt="mark"></p><h3 id="什么是-SpringBoot-Admin？"><a href="#什么是-SpringBoot-Admin？" class="headerlink" title="什么是 SpringBoot Admin？"></a>什么是 SpringBoot Admin？</h3><p>Spring Boot Admin 是一个管理和监控你的 Spring Boot 应用程序的应用程序。 这些应用程序通过 Spring Boot Admin Client（通过 HTTP）注册或者使用 Spring Cloud（例如 Eureka）发现。 UI只是 Spring Boot Actuator 端点上的一个 AngularJs 应用程序。<br><a id="more"></a></p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><p>首先在 IDEA 创建一个 SpringBoot 项目，把它当作 server 端，工程如下：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/hIKaIkCE8a.png-1" alt="mark"></p><p>然后在 pom.xml 中引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-server-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继续在启动类 SpringbootAdminApplication.java 中引入注解 <strong>@EnableAdminServer</strong> ，然后运行项目：</p><p>访问 <a href="http://localhost:8084/" target="_blank" rel="noopener">http://localhost:8084/</a>  即可：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/C55mBbf8LH.png-1" alt="mark"></p><p>此时会发现没有任何应用程序的信息。</p><p>接下来我们新建一个 SpringBoot 项目，把它当作客户端程序，工程如下：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/9EGaFH3Gb7.png-1" alt="mark"></p><p>在 pom.xml 中添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 application.yml 中设置：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/3AL0J6I16b.png-1" alt="mark"></p><p>spring.boot.admin.url=http:localhost:8094 用于将当前应用注册到 Spring Boot Admin。</p><p>还可以设置，spring.boot.admin.client.name: （应用程序的名字）不设置的话会有默认的名字</p><p>此时把两个项目运行起来：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/IGEBDm4eJ7.png-1" alt="mark"></p><p>点击图中的 <strong>detail</strong> 按钮：可以看到应用程序的健康值、内存、JVM、GC 等信息。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/GJBjGF512G.png-1" alt="mark"></p><p><strong>metrics</strong> 信息：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/gdbj21Fk19.png-1" alt="mark"></p><p><strong>环境</strong> 信息：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/eglbcgE9C5.png-1" alt="mark"></p><p><strong>log</strong> 信息：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/IkeJkaEGcI.png-1" alt="mark"></p><p><strong>JMX</strong> 信息：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/e3Ei3l6ieF.png-1" alt="mark"></p><p><strong>线程</strong> 信息：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/ClFekkJKB8.png-1" alt="mark"></p><p><strong>Trace</strong> 追踪信息：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/J6m9b43F8d.png-1" alt="mark"></p><p>还可以下载 Heapdump 文件。</p><p>刚才首页的应用列表后面有个红色的 ×，我们可以将注册上去的应用移除，但是只要你不把程序停掉，它立马又会注册上去。</p><p>还有就是应用列表的 version 和 info 上面的图中为空，下面看看怎么把它变出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info.groupId: @project.groupId@</span><br><span class="line">info.artifactId: @project.artifactId@</span><br><span class="line">info.version: @project.version@</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/3E5hlG7heJ.png-1" alt="mark"></p><p>重新运行客户端程序，刷新页面可以发现：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/A0FBLLK9LE.png-1" alt="mark"></p><p>还可以查询应用程序的事件变化：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/E9LfBJGaB3.png-1" alt="mark"></p><h3 id="客户端应用程序"><a href="#客户端应用程序" class="headerlink" title="客户端应用程序"></a>客户端应用程序</h3><h4 id="JMX-bean管理"><a href="#JMX-bean管理" class="headerlink" title="JMX bean管理"></a>JMX bean管理</h4><p>要在管理界面中与JMX-beans进行交互，您必须在客户端应用程序中包含 Jolokia,</p><p>pom.xml 加入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jolokia<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jolokia-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启客户端程序后，就可以在这里与 JMX 做交互了：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180117/g82cD16kBf.png-1" alt="mark"></p><p>还有很多 SpringBoot Admin 客户端配置选项：</p><p><a href="http://codecentric.github.io/spring-boot-admin/1.5.6/#spring-boot-admin-client" target="_blank" rel="noopener">http://codecentric.github.io/spring-boot-admin/1.5.6/#spring-boot-admin-client</a></p><h3 id="服务端程序"><a href="#服务端程序" class="headerlink" title="服务端程序"></a>服务端程序</h3><p>也有些 SpringBoot Admin 服务端程序配置选项：</p><p><a href="http://codecentric.github.io/spring-boot-admin/1.5.6/#spring-boot-admin-server" target="_blank" rel="noopener">http://codecentric.github.io/spring-boot-admin/1.5.6/#spring-boot-admin-server</a></p><p>官方文档里面还有些关于服务下线消息通知的知识，想了解的可以查看：</p><p><a href="http://codecentric.github.io/spring-boot-admin/1.5.6/#_notifications" target="_blank" rel="noopener">http://codecentric.github.io/spring-boot-admin/1.5.6/#_notifications</a></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="">http://codecentric.github.io/spring-boot-admin/1.5.6/</a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请注明文章原始地址为：<a href="http://www.54tianzhisheng.cn/2018/01/17/SpringBoot-Admin/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/17/SpringBoot-Admin/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180107/m1b2jfCc9I.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是-SpringBoot-Admin？&quot;&gt;&lt;a href=&quot;#什么是-SpringBoot-Admin？&quot; class=&quot;headerlink&quot; title=&quot;什么是 SpringBoot Admin？&quot;&gt;&lt;/a&gt;什么是 SpringBoot Admin？&lt;/h3&gt;&lt;p&gt;Spring Boot Admin 是一个管理和监控你的 Spring Boot 应用程序的应用程序。 这些应用程序通过 Spring Boot Admin Client（通过 HTTP）注册或者使用 Spring Cloud（例如 Eureka）发现。 UI只是 Spring Boot Actuator 端点上的一个 AngularJs 应用程序。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Lombok 看这篇就够了</title>
    <link href="http://yoursite.com/2018/01/09/lombok/"/>
    <id>http://yoursite.com/2018/01/09/lombok/</id>
    <published>2018-01-08T16:00:00.000Z</published>
    <updated>2018-03-06T16:15:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/7JfK07cCbh.png-1" alt="mark"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>自从进公司实习后，项目代码中能用 Lombok 的都用了，毕竟这么好的轮子要充分利用好。也可以减少一些 get/set/toString 方法的编写，虽说 IDEA 的插件可以自动生成 get/set/toString 方法，但是使用 Lombok 可以让代码更简洁。<br><a id="more"></a><br>下面看看如何在 IDEA　中如何安装 Lombok：</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>打开 IDEA 的 Settings 面板，并选择 Plugins 选项，然后点击 “Browse repositories”</p><p>在输入框输入”lombok”，得到搜索结果，点击安装，然后安装提示重启 IDEA，安装成功;</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180106/C33FG37Gk4.png-1" alt="mark"></p><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>在自己的项目里添加 lombok 的编译支持，在 pom 文件里面添加 dependency</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.16.18&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="怎么使用？"><a href="#怎么使用？" class="headerlink" title="怎么使用？"></a>怎么使用？</h3><p>在实体类上引入相关的注解就行：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180106/aCEc8ileJg.png-1" alt="mark"></p><h3 id="有哪些注解？"><a href="#有哪些注解？" class="headerlink" title="有哪些注解？"></a>有哪些注解？</h3><ul><li>@Data</li><li>@Setter</li><li>@Getter</li><li>@Slf4j</li><li>@AllArgsConstructor</li><li>@NoArgsConstructor</li><li>@EqualsAndHashCode</li><li>@NonNull</li><li>@Cleanup</li><li>@ToString</li><li>@RequiredArgsConstructor</li><li>@Value</li><li>@SneakyThrows</li><li>@Synchronized</li></ul><h3 id="注解详解"><a href="#注解详解" class="headerlink" title="注解详解"></a>注解详解</h3><p><strong>@Data</strong></p><p>注解在 <strong>类</strong> 上；提供类所有属性的 get 和 set 方法，此外还提供了equals、canEqual、hashCode、toString 方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/mHj1eak6fJ.png-1" alt="mark"></p><p><strong>@Setter</strong></p><p>注解在 <strong>属性</strong> 上；为单个属性提供 set 方法; 注解在 <strong>类</strong> 上，为该类所有的属性提供 set 方法， 都提供默认构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/lkkff2b6Dc.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/J9mC8FGfc0.png-1" alt="mark"></p><p><strong>@Getter</strong></p><p>注解在 <strong>属性</strong> 上；为单个属性提供 get 方法; 注解在 <strong>类</strong> 上，为该类所有的属性提供 get 方法，都提供默认构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/d0F5h97J5f.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/K0m81cFd6g.png-1" alt="mark"></p><p><strong>@Slf4j</strong></p><p>注解在 <strong>类</strong> 上；为类提供一个 属性名为 log 的日志对象，提供默认构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/BChd89Cbh5.png-1" alt="mark"></p><p><strong>@AllArgsConstructor</strong></p><p>注解在 <strong>类</strong> 上；为类提供一个全参的构造方法，加了这个注解后，类中不提供默认构造方法了。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/4iji9AJ0fE.png-1" alt="mark"></p><p><strong>@NoArgsConstructor</strong></p><p>注解在 <strong>类</strong> 上；为类提供一个无参的构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180107/JcdfmhDAaB.png-1" alt="mark"></p><p><strong>@EqualsAndHashCode</strong></p><p>注解在 <strong>类</strong> 上, 可以生成 equals、canEqual、hashCode 方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/CKHe7EICGd.png-1" alt="mark"></p><p><strong>@NonNull</strong></p><p>注解在 <strong>属性</strong> 上，会自动产生一个关于此参数的非空检查，如果参数为空，则抛出一个空指针异常，也会有一个默认的无参构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/g6Lh1eh1jm.png-1" alt="mark"></p><p><strong>@Cleanup</strong></p><p>这个注解用在 <strong>变量</strong> 前面，可以保证此变量代表的资源会被自动关闭，默认是调用资源的 close() 方法，如果该资源有其它关闭方法，可使用 @Cleanup(“methodName”) 来指定要调用的方法，也会生成默认的构造方法</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/Ba1bDkKb9J.png-1" alt="mark"></p><p><strong>@ToString</strong></p><p>这个注解用在 <strong>类</strong> 上，可以生成所有参数的 toString 方法，还会生成默认的构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/7LjglDeH8e.png-1" alt="mark"></p><p><strong>@RequiredArgsConstructor</strong></p><p>这个注解用在 <strong>类</strong> 上，使用类中所有带有 @NonNull 注解的或者带有 final 修饰的成员变量生成对应的构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/CBgAF4ei8m.png-1" alt="mark"></p><p><strong>@Value</strong></p><p>这个注解用在 <strong>类</strong> 上，会生成含所有参数的构造方法，get 方法，此外还提供了equals、hashCode、toString 方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/b6KeAg0ABi.png-1" alt="mark"></p><p><strong>@SneakyThrows</strong></p><p>这个注解用在 <strong>方法</strong> 上，可以将方法中的代码用 try-catch 语句包裹起来，捕获异常并在 catch 中用 Lombok.sneakyThrow(e) 把异常抛出，可以使用 @SneakyThrows(Exception.class) 的形式指定抛出哪种异常，也会生成默认的构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/IfCKh1FGbh.png-1" alt="mark"></p><p><strong>@Synchronized</strong></p><p>这个注解用在 <strong>类方法</strong> 或者 <strong>实例方法</strong> 上，效果和 synchronized 关键字相同，区别在于锁对象不同，对于类方法和实例方法，synchronized 关键字的锁对象分别是类的 class 对象和 this 对象，而 @Synchronized 的锁对象分别是 私有静态 final 对象 lock 和 私有 final 对象 lock，当然，也可以自己指定锁对象，此外也提供默认的构造方法。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180108/L95jIc7eJi.png-1" alt="mark"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上注解可根据需要一起搭配使用！</p><p><strong>虽说轮子好，但是我们不仅要知其然，也要知其所以然！</strong></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请注明原创地址：<a href="http://www.54tianzhisheng.cn/2018/01/07/lombok/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/07/lombok/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180107/7JfK07cCbh.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;自从进公司实习后，项目代码中能用 Lombok 的都用了，毕竟这么好的轮子要充分利用好。也可以减少一些 get/set/toString 方法的编写，虽说 IDEA 的插件可以自动生成 get/set/toString 方法，但是使用 Lombok 可以让代码更简洁。&lt;br&gt;
    
    </summary>
    
    
      <category term="lombok" scheme="http://yoursite.com/tags/lombok/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot Kafka 整合使用</title>
    <link href="http://yoursite.com/2018/01/05/SpringBoot-Kafka/"/>
    <id>http://yoursite.com/2018/01/05/SpringBoot-Kafka/</id>
    <published>2018-01-04T16:00:00.000Z</published>
    <updated>2018-03-06T16:20:11.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180105/DKcBEKHimB.jpg-1" alt="mark"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>假设你了解过 SpringBoot 和 Kafka。<br><a id="more"></a><br>1、SpringBoot</p><p>如果对 SpringBoot 不了解的话，建议去看看 <a href="http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">DD 大佬</a> 和 <a href="http://www.ityouknow.com/spring-boot.html" target="_blank" rel="noopener">纯洁的微笑</a> 的系列博客。</p><p>2、Kafka</p><p>Kafka 的话可以看看我前两天写的博客 ： <a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/" target="_blank" rel="noopener">Kafka 安装及快速入门</a>   学习的话自己开台虚拟机自己手动搭建环境吧，有条件的买服务器。</p><p>注意：<strong>一定要亲自自己安装实践</strong>，接下来我们将这两个进行整合。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><h4 id="项目整体架构："><a href="#项目整体架构：" class="headerlink" title="项目整体架构："></a>项目整体架构：</h4><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180105/c6jC85Bbk4.png-1" alt="mark"></p><p>使用 IDEA 创建 SpringBoot 项目，这个很简单了，这里不做过多的讲解。</p><p>1、pom 文件代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zhisheng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kafka-learning<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>kafka-learning<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot + kafka<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主要引入了  spring-kafka 、lombok 、 gson 依赖。</p><p>2、消息实体类 Message.java  如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;    <span class="comment">//id</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">//消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date sendTime;  <span class="comment">//时间戳</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、消息发送类 KafkaSender.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Gson gson = <span class="keyword">new</span> GsonBuilder().create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送消息方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message();</span><br><span class="line">        message.setId(System.currentTimeMillis());</span><br><span class="line">        message.setMsg(UUID.randomUUID().toString());</span><br><span class="line">        message.setSendTime(<span class="keyword">new</span> Date());</span><br><span class="line">        log.info(<span class="string">"+++++++++++++++++++++  message = &#123;&#125;"</span>, gson.toJson(message));</span><br><span class="line">        kafkaTemplate.send(<span class="string">"zhisheng"</span>, gson.toJson(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，发送消息代码就实现了。</p><p>这里关键的代码为 <code>kafkaTemplate.send()</code>  方法，<code>zhisheng</code> 是 Kafka 里的 topic ，这个 topic 在 Java 程序中是不需要提前在 Kafka 中设置的，因为它会在发送的时候自动创建你设置的 topic， <code>gson.toJson(message)</code>   是消息内容，这里暂时先说这么多了，不详解了，后面有机会继续把里面源码解读写篇博客出来（因为中途碰到坑，老子跟了几遍源码）。</p><p>4、消息接收类  KafkaReceiver.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = &#123;<span class="string">"zhisheng"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">(ConsumerRecord&lt;?, ?&gt; record)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Optional&lt;?&gt; kafkaMessage = Optional.ofNullable(record.value());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kafkaMessage.isPresent()) &#123;</span><br><span class="line"></span><br><span class="line">            Object message = kafkaMessage.get();</span><br><span class="line"></span><br><span class="line">            log.info(<span class="string">"----------------- record ="</span> + record);</span><br><span class="line">            log.info(<span class="string">"------------------ message ="</span> + message);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端 consumer 接收消息特别简单，直接用 <code>@KafkaListener</code> 注解即可，并在监听中设置监听的 <code>topic</code> ，<code>topics</code> 是一个数组所以是可以绑定多个主题的，上面的代码中修改为 <code>@KafkaListener(topics = {&quot;zhisheng&quot;,&quot;tian&quot;})</code>  就可以同时监听两个 <code>topic</code> 的消息了。需要注意的是：这里的 topic 需要和消息发送类 KafkaSender.java 中设置的 topic 一致。</p><p>5、启动类 KafkaApplication.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(KafkaApplication.class, args);</span><br><span class="line"></span><br><span class="line">        KafkaSender sender = context.getBean(KafkaSender.class);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//调用消息发送类中的消息发送方法</span></span><br><span class="line">            sender.send();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、配置文件 application.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#============== kafka ===================</span><br><span class="line"># 指定kafka 代理地址，可以多个</span><br><span class="line">spring.kafka.bootstrap-servers=192.168.153.135:9092</span><br><span class="line"></span><br><span class="line">#=============== provider  =======================</span><br><span class="line"></span><br><span class="line">spring.kafka.producer.retries=0</span><br><span class="line"># 每次批量发送消息的数量</span><br><span class="line">spring.kafka.producer.batch-size=16384</span><br><span class="line">spring.kafka.producer.buffer-memory=33554432</span><br><span class="line"></span><br><span class="line"># 指定消息key和消息体的编解码方式</span><br><span class="line">spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line">spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.StringSerializer</span><br><span class="line"></span><br><span class="line">#=============== consumer  =======================</span><br><span class="line"># 指定默认消费者group id</span><br><span class="line">spring.kafka.consumer.group-id=test-consumer-group</span><br><span class="line"></span><br><span class="line">spring.kafka.consumer.auto-offset-reset=earliest</span><br><span class="line">spring.kafka.consumer.enable-auto-commit=true</span><br><span class="line">spring.kafka.consumer.auto-commit-interval=100</span><br><span class="line"></span><br><span class="line"># 指定消息key和消息体的编解码方式</span><br><span class="line">spring.kafka.consumer.key-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br><span class="line">spring.kafka.consumer.value-deserializer=org.apache.kafka.common.serialization.StringDeserializer</span><br></pre></td></tr></table></figure><p>spring.kafka.bootstrap-servers 后面设置你安装的 Kafka 的机器 IP 地址和端口号 9092。</p><p>如果你只是简单整合下，其他的几个默认就好了。</p><h3 id="Kafka-设置"><a href="#Kafka-设置" class="headerlink" title="Kafka 设置"></a>Kafka 设置</h3><p>在你安装的 Kafka 目录文件下：</p><h4 id="启动-zk"><a href="#启动-zk" class="headerlink" title="启动 zk"></a>启动 zk</h4><p>使用安装包中的脚本启动单节点 Zookeeper 实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><h4 id="启动-Kafka-服务"><a href="#启动-Kafka-服务" class="headerlink" title="启动 Kafka 服务"></a>启动 Kafka 服务</h4><p>使用 <code>kafka-server-start.sh</code> 启动 kafka 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh  config/server.properties</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/Lc2CiKfIee.png-1" alt="mark"></p><p>启动成功后！</p><p><strong>千万注意</strong>： 记得将你的虚拟机或者服务器关闭防火墙或者开启 Kafka 的端口 9092。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180105/HBB0LCDdj8.png-1" alt="mark"></p><p>出现这就代表整合成功了！</p><hr><p>我们看下 Kafka 中的 topic 列表就</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180105/DI6cmll4BC.png-1" alt="mark"></p><p>就会发现刚才我们程序中的 <code>zhisheng</code> 已经自己创建了。</p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请务必注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/05/SpringBoot-Kafka/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180105/DKcBEKHimB.jpg-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;假设你了解过 SpringBoot 和 Kafka。&lt;br&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>为什么要重新运营以前的公众号呢？</title>
    <link href="http://yoursite.com/2018/01/04/weixin/"/>
    <id>http://yoursite.com/2018/01/04/weixin/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-03-06T16:21:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/mL5G5acdd4.png-1" alt="mark"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>老读者可能会发现现在我的公众号已经改名了。（由 “猿blog”  变成  “zhisheng” 了，细心的童鞋会发现不仅名字变了， ID 也变了，但是图片还没改，暂时还没想到好的 logo 图片），下面说说为啥吧！<br><a id="more"></a></p><h3 id="听我瞎-BB"><a href="#听我瞎-BB" class="headerlink" title="听我瞎 BB"></a>听我瞎 BB</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/k1a984Emlc.png-1" alt="mark"></p><p>上图是两年前公众号群发的第一条信息，那时自己还是在学校，如今已经进入了社会，在公司实习了。记得当初开这个公众号的原因是因为几个年轻人有着梦想，打算一起做点东西，当时一腔热血的自己立马就先申请了个公众号，后来 “东西” 倒是没做，反倒是我自己慢慢的在微信公众号分享一些文章，然后那时自己也写博客（算算自己写博客应该快三年了，坚持真不易啊），所以偶尔也把自己的博客分享在微信公众号上。</p><p>但是好景不长，那时的微信公众号排版真尼玛难用的一批，作为一个理工科的男生，本来自己做事一般细心和耐心，无奈，把这么好的一个童鞋都给逼坏了。我现在还是得吐槽下，如今的微信公众号后台排版还是那么差。但是可能因为需求比较多了，所以就有人做出了工具（将 markdown 排版后在将整个样式复制粘贴到微信公众号后台），这样一篇排版还算不错的博客就出来了。</p><p>自己早就知道了这么个工具，以前看 DD 的博客的时候就发现了这个工具，但是很久没更新的微信公众号，自己也不怎么想再管理。</p><p>有人就要问了？那为啥现在又要开始跟新了呢？</p><p>我只想说：“贱人就是矫情！！！又想瞎折腾下。”，反正自己的博客也在不断的更新，偶尔顺带把文章同步到微信公众号其实也是可以的。在学校的时候时间比较多，那时真的是时间比较多，后悔没好好坚持运营下来。现在工作了，自己工作之外的时间较少，除了学习，偶尔写写博客，娱乐时间比较少，都是大学时宅的。</p><p>前段时间被人 “忽悠” 说继续更新公众号，那时刚好也快 2018 年了，自己也想给自己定几个目标，在元旦的那天，想想还是继续更新微信公众号吧，所以你也看得到最近我的更新了，可能最近的更新比较有规律，因为这些文章大部分是之前就已经写好了的，已经发过在我的博客里了。估计把这些文章更新完后，就不会每天都更新我自己的文章了。</p><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>说下微信公众号的定位吧：</p><p>1、我的技术博客应该都会同步在这里的。</p><p>2、分享自己平时的随笔文章。（比如这篇。。。）</p><p>3、除了技术文章，当然还有平时自己的 奇淫技巧 （包括但不限于写作方式、推荐好用的软件等）</p><p>4、分享自己觉得不错的文章（别人的，尽量征得同意，一定会备注原创地址的）</p><p>5、如果你也写博客，但是阅读量很小的话，可以考虑自荐。（注：文章我可能会审批，必须要觉得不错的文章）</p><p>6、分享一些学习视频和书籍</p><p>7、后期可能会搞工作内推</p><p>。。。</p><p>暂时只想到这些了</p><h3 id="问题来了"><a href="#问题来了" class="headerlink" title="问题来了"></a>问题来了</h3><p>因为工作了，所以时间少，运营这微信公众号可能需要花费我不少工作之外的时间。</p><p>如果可以的话，我希望能找到一个能帮我分担点的朋友。</p><p>注：<strong>无偿的，如果介意的话，下面就不用再看了。</strong></p><hr><p>说点简单的要求吧：</p><p>1、细心、耐心的 boy  or  girl 都行</p><p>2、起码要知道点编程方面的知识</p><p>3、能坚持下来</p><p>4、对新技术有敏感的嗅觉</p><p>5、最后一点就是你要有点时间了，希望不耽误你学习</p><p>再说下能给你带来的 <strong>好处</strong> 吧：</p><p>1、肯定能增加你的运营能力（再去互联网公司投运营岗位会有优势的）</p><p>2、本人一开始会亲自教授该怎么做，所以没经验的朋友不用担心</p><p>3、可以增加和大牛勾搭的机会，你们懂的。。</p><p>4、本人可以亲自传授经验（编程和生活点滴经验）</p><p><strong>如果你有意愿的话，请加我 QQ ： 1041218129  聊聊吧</strong></p><hr><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180103/mL5G5acdd4.png-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;老读者可能会发现现在我的公众号已经改名了。（由 “猿blog”  变成  “zhisheng” 了，细心的童鞋会发现不仅名字变了， ID 也变了，但是图片还没改，暂时还没想到好的 logo 图片），下面说说为啥吧！&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 安装及快速入门</title>
    <link href="http://yoursite.com/2018/01/04/Kafka/"/>
    <id>http://yoursite.com/2018/01/04/Kafka/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-03-06T16:14:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/2K14BekelF.jpg-1" alt="mark"></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>官网：<a href="http://kafka.apache.org/" target="_blank" rel="noopener">http://kafka.apache.org/</a></p><p>Apache Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，之后成为Apache项目的一部分。Kafka是一种快速、可扩展的、设计内在就是分布式的，分区的和可复制的提交日志服务。<br><a id="more"></a><br>Apache Kafka与传统消息系统相比，有以下不同：</p><ul><li><p>它被设计为一个分布式系统，易于向外扩展；</p></li><li><p>它同时为发布和订阅提供高吞吐量；</p></li><li><p>它支持多订阅者，当失败时能自动平衡消费者；</p></li><li><p>它将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。</p></li></ul><h3 id="安装-kafka"><a href="#安装-kafka" class="headerlink" title="安装 kafka"></a>安装 kafka</h3><p>下载地址：<a href="https://kafka.apache.org/downloads" target="_blank" rel="noopener">https://kafka.apache.org/downloads</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.shuosc.org/apache/kafka/1.0.0/kafka_2.11-1.0.0.tgz</span><br></pre></td></tr></table></figure><p>解压：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf kafka_2.11-1.0.0.tgz</span><br><span class="line"></span><br><span class="line">cd /usr/local/kafka_2.11-1.0.0/</span><br></pre></td></tr></table></figure></p><p>修改 kafka-server 的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/kafka/config/server.properties</span><br></pre></td></tr></table></figure><p>修改其中的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">broker.id=1</span><br><span class="line">log.dir=/data/kafka/logs-1</span><br></pre></td></tr></table></figure><h3 id="功能验证："><a href="#功能验证：" class="headerlink" title="功能验证："></a>功能验证：</h3><h4 id="1、启动-zk"><a href="#1、启动-zk" class="headerlink" title="1、启动 zk"></a>1、启动 zk</h4><p>使用安装包中的脚本启动单节点 Zookeeper 实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/zookeeper-server-start.sh -daemon config/zookeeper.properties</span><br></pre></td></tr></table></figure><h4 id="2、启动Kafka-服务"><a href="#2、启动Kafka-服务" class="headerlink" title="2、启动Kafka 服务"></a>2、启动Kafka 服务</h4><p>使用 <code>kafka-server-start.sh</code> 启动 kafka 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh  config/server.properties</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/Lc2CiKfIee.png-1" alt="mark"></p><h4 id="3、创建-topic"><a href="#3、创建-topic" class="headerlink" title="3、创建 topic"></a>3、创建 topic</h4><p>使用 <code>kafka-topics.sh</code> 创建单分区单副本的 topic test：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test</span><br></pre></td></tr></table></figure><p>查看 topic 列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><p>查询创建的 topic 列表报错：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/c3K5D805eI.png-1" alt="mark"></p><p>解决方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure><p>将 host 里的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         ip6-localhost ip6-localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure><p>方法参考：<a href="https://stackoverflow.com/questions/28109669/zookeeper-unable-to-open-socket-to-localhost-000000012181" target="_blank" rel="noopener">zookeeper unable to open socket to localhost/0:0:0:0:0:0:0:1:2181</a></p><p>再次查询就不报错了。</p><h4 id="4、产生消息"><a href="#4、产生消息" class="headerlink" title="4、产生消息"></a>4、产生消息</h4><p>使用 <code>kafka-console-producer.sh</code> 发送消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/4F1EAgdmI1.png-1" alt="mark"></p><h4 id="5、消费消息"><a href="#5、消费消息" class="headerlink" title="5、消费消息"></a>5、消费消息</h4><p>使用 <code>kafka-console-consumer.sh</code> 接收消息并在终端打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic test --from-beginning</span><br></pre></td></tr></table></figure><p>打开个新的命令窗口执行上面命令即可查看信息：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/c8mg8jJFki.png-1" alt="mark"></p><h4 id="6、查看描述-topics-信息"><a href="#6、查看描述-topics-信息" class="headerlink" title="6、查看描述 topics 信息"></a>6、查看描述 topics 信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic test</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Topic:testPartitionCount:1ReplicationFactor:1Configs:</span><br><span class="line">Topic: testPartition: 0Leader: 1Replicas: 1Isr: 1</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/6JlmHdLcI5.png-1" alt="mark"></p><p>第一行给出了所有分区的摘要，每个附加行给出了关于一个分区的信息。 由于我们只有一个分区，所以只有一行。</p><p>“Leader”: 是负责给定分区的所有读取和写入的节点。 每个节点将成为分区随机选择部分的领导者。</p><p>“Replicas”: 是复制此分区日志的节点列表，无论它们是否是领导者，或者即使他们当前处于活动状态。</p><p>“Isr”: 是一组“同步”副本。这是复制品列表的子集，当前活着并被引导到领导者。</p><h3 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h3><p>Kafka 支持两种模式的集群搭建：可以在单机上运行多个 broker 实例来实现集群，也可在多台机器上搭建集群，下面介绍下如何实现单机多 broker 实例集群，其实很简单，只需要如下配置即可。</p><h4 id="单机多broker-集群配置"><a href="#单机多broker-集群配置" class="headerlink" title="单机多broker 集群配置"></a>单机多broker 集群配置</h4><p>利用单节点部署多个 broker。 不同的 broker 设置不同的 id，监听端口及日志目录。 例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp config/server.properties config/server-2.properties</span><br><span class="line"></span><br><span class="line">cp config/server.properties config/server-3.properties</span><br><span class="line"></span><br><span class="line">vim config/server-2.properties</span><br><span class="line"></span><br><span class="line">vim config/server-3.properties</span><br></pre></td></tr></table></figure><p>修改 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">broker.id=2</span><br><span class="line"></span><br><span class="line">listeners = PLAINTEXT://your.host.name:9093</span><br><span class="line"></span><br><span class="line">log.dir=/data/kafka/logs-2</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">broker.id=3</span><br><span class="line"></span><br><span class="line">listeners = PLAINTEXT://your.host.name:9094</span><br><span class="line"></span><br><span class="line">log.dir=/data/kafka/logs-3</span><br></pre></td></tr></table></figure><p>启动Kafka服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-server-start.sh config/server-2.properties &amp;</span><br><span class="line"></span><br><span class="line">bin/kafka-server-start.sh config/server-3.properties &amp;</span><br></pre></td></tr></table></figure><p>至此，单机多broker实例的集群配置完毕。</p><h4 id="多机多-broker-集群配置"><a href="#多机多-broker-集群配置" class="headerlink" title="多机多 broker 集群配置"></a>多机多 broker 集群配置</h4><p>分别在多个节点按上述方式安装 Kafka，配置启动多个 Zookeeper 实例。</p><p>假设三台机器 IP 地址是 ： 192.168.153.135， 192.168.153.136， 192.168.153.137</p><p>分别配置多个机器上的 Kafka 服务，设置不同的 broker id，zookeeper.connect 设置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim config/server.properties</span><br></pre></td></tr></table></figure><p>里面的 <code>zookeeper.connect</code></p><p>修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zookeeper.connect=192.168.153.135:2181,192.168.153.136:2181,192.168.153.137:2181</span><br></pre></td></tr></table></figure><h3 id="使用-Kafka-Connect-来导入-导出数据"><a href="#使用-Kafka-Connect-来导入-导出数据" class="headerlink" title="使用 Kafka Connect 来导入/导出数据"></a>使用 Kafka Connect 来导入/导出数据</h3><p>从控制台写入数据并将其写回控制台是一个方便的起点，但您可能想要使用其他来源的数据或将数据从 Kafka 导出到其他系统。对于许多系统，您可以使用 Kafka Connect 来导入或导出数据，而不必编写自定义集成代码。</p><p>Kafka Connect 是 Kafka 包含的一个工具，可以将数据导入和导出到 Kafka。它是一个可扩展的工具，运行 连接器，实现与外部系统交互的自定义逻辑。在这个快速入门中，我们将看到如何使用简单的连接器运行 Kafka Connect，这些连接器将数据从文件导入到 Kafka topic，并将数据从 Kafka topic 导出到文件。</p><p>首先，我们将通过创建一些种子数据开始测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;zhisheng\ntian&quot; &gt; test.txt</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/79EG4ilBAH.png-1" alt="mark"></p><p>接下来，我们将启动两个以独立模式运行的连接器，这意味着它们将在单个本地专用进程中运行。我们提供三个配置文件作为参数。首先是 Kafka Connect 过程的配置，包含常见的配置，例如要连接的 Kafka 代理以及数据的序列化格式。其余的配置文件都指定一个要创建的连接器。这些文件包括唯一的连接器名称，要实例化的连接器类以及连接器所需的任何其他配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/connect-standalone.sh  config/connect-standalone.properties config/connect-file-source.properties config/connect-file-sink.properties</span><br></pre></td></tr></table></figure><p>Kafka 附带的这些示例配置文件使用您之前启动的默认本地群集配置，并创建两个连接器：第一个是源连接器，用于读取输入文件中的行，并将每个连接生成为 Kafka topic，第二个为连接器它从 Kafka topic 读取消息，并在输出文件中产生每行消息。</p><p>在启动过程中，您会看到一些日志消息，其中一些指示连接器正在实例化。Kafka Connect 进程启动后，源连接器应该开始读取 test.txt topic connect-test，并将其生成 topic ，并且接收器连接器应该开始读取 topic 中的消息 connect-test 并将其写入文件 test.sink.txt。我们可以通过检查输出文件的内容来验证通过整个管道传输的数据：</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/Jh18BCJcb6.png-1" alt="mark"></p><p>数据存储在 Kafka topic 中 connect-test，因此我们也可以运行控制台使用者来查看 topic 中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic connect-test --from-beginning</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/LBC5fF1LK6.png-1" alt="mark"></p><p>连接器继续处理数据，所以我们可以将数据添加到文件中，并看到它在管道中移动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo zhishengtian&gt;&gt; test.txt</span><br><span class="line">echo zhishengtian2&gt;&gt; test.txt</span><br><span class="line">echo zhishengtian3&gt;&gt; test.txt</span><br><span class="line">echo zhishengtian4&gt;&gt; test.txt</span><br></pre></td></tr></table></figure><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/0DH6K1dkBA.png-1" alt="mark"></p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180104/6JLE96B87K.png-1" alt="mark"></p><h3 id="使用-Kafka-流来处理数据"><a href="#使用-Kafka-流来处理数据" class="headerlink" title="使用 Kafka 流来处理数据"></a>使用 Kafka 流来处理数据</h3><p>Kafka Streams 是用于构建关键任务实时应用程序和微服务的客户端库，输入和/或输出数据存储在 Kafka 集群中。Kafka Streams 结合了在客户端编写和部署标准 Java 和 Scala 应用程序的简单性以及 Kafka 服务器端集群技术的优势，使这些应用程序具有高度可伸缩性，弹性，容错性，分布式等特性。</p><p>可参考官网入门案例：<a href="http://kafka.apache.org/10/documentation/streams/quickstart" target="_blank" rel="noopener">http://kafka.apache.org/10/documentation/streams/quickstart</a></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1、<a href="https://www.mtyun.com/library/how-to-install-kafka-on-centos7" target="_blank" rel="noopener">在CentOS 7上安装Kafka</a></p><p>2、<a href="http://kafka.apache.org/10/documentation/streams/quickstart" target="_blank" rel="noopener">http://kafka.apache.org/10/documentation/streams/quickstart</a></p><h3 id="关注我"><a href="#关注我" class="headerlink" title="关注我"></a>关注我</h3><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg" alt="mark"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>转载请注明原创地址为：<a href="http://www.54tianzhisheng.cn/2018/01/04/Kafka/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2018/01/04/Kafka/</a></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180104/2K14BekelF.jpg-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;官网：&lt;a href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://kafka.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Apache Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，之后成为Apache项目的一部分。Kafka是一种快速、可扩展的、设计内在就是分布式的，分区的和可复制的提交日志服务。&lt;br&gt;
    
    </summary>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Windows 下安装 Consul</title>
    <link href="http://yoursite.com/2017/12/27/consul-install/"/>
    <id>http://yoursite.com/2017/12/27/consul-install/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-03-06T16:09:33.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171227/Da4dGccaEd.jpg-1" alt="mark"></p><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>从刚工作就开始接触 Consul，中途自己也有两个项目和 Consul 有关，后面有机会再讲讲，网上关于这个的资料还比较少。因为明天有 Consul 的技术分享，所以自己今天下午在官网看了下相关的介绍。<br><a id="more"></a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Consul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,  由 HashiCorp 公司用 Go 语言开发,  基于 Mozilla Public License 2.0 的协议进行开源。Consul 支持健康检查,  并允许 HTTP 和 DNS 协议调用 API 存储键值对。<br>命令行超级好用的虚拟机管理软件 vgrant 也是 HashiCorp 公司开发的产品。一致性协议采用 Raft 算法,  用来保证服务的高可用， 使用 GOSSIP 协议管理成员和广播消息, 并且支持 ACL 访问控制。</p><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>去官网下载：<a href="https://www.consul.io/downloads.html" target="_blank" rel="noopener">https://www.consul.io/downloads.html</a></p><p>得到一个 zip 压缩包</p><p>在你想要安装的位置解压就行，只有一个 consul.exe 文件（我的解压位置是：D:\software）</p><p>设置环境变量（在 path 中新增一条）：</p><p>D:\software</p><p>cmd 命令窗口启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -dev</span><br></pre></td></tr></table></figure><p>consul 自带 UI 界面，打开网址：<a href="http://localhost:8500" target="_blank" rel="noopener">http://localhost:8500</a> ，可以看到当前注册的服务界面。</p><p><img src="http://ohfk1r827.bkt.clouddn.com/blog/171227/7Alcc9AECH.png-1" alt="mark"></p><h3 id="Consul-优势"><a href="#Consul-优势" class="headerlink" title="Consul 优势"></a>Consul 优势</h3><ul><li>使用 Raft 算法来保证一致性, 比复杂的 Paxos 算法更直接. 相比较而言, zookeeper 采用的是 Paxos, 而 etcd 使用的则是 Raft.</li><li>支持多数据中心，内外网的服务采用不同的端口进行监听。 多数据中心集群可以避免单数据中心的单点故障,而其部署则需要考虑网络延迟, 分片等情况等. zookeeper 和 etcd 均不提供多数据中心功能的支持.</li><li>支持健康检查. etcd 不提供此功能.</li><li>支持 http 和 dns 协议接口. zookeeper 的集成较为复杂, etcd 只支持 http 协议.</li><li>官方提供web管理界面, etcd 无此功能.</li></ul><p>综合比较, Consul 作为服务注册和配置管理的新星, 比较值得关注和研究.</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fp3jkmizmpj30o00didgn.jpg" alt=""></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><blockquote><p>本文首发于：<a href="http://www.54tianzhisheng.cn/" target="_blank" rel="noopener">zhisheng的博客</a></p><p>地址为：<a href="http://www.54tianzhisheng.cn/2017/12/27/consul-install/" target="_blank" rel="noopener">http://www.54tianzhisheng.cn/2017/12/27/consul-install/</a>    转载请注明地址！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/171227/Da4dGccaEd.jpg-1&quot; alt=&quot;mark&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h3&gt;&lt;p&gt;从刚工作就开始接触 Consul，中途自己也有两个项目和 Consul 有关，后面有机会再讲讲，网上关于这个的资料还比较少。因为明天有 Consul 的技术分享，所以自己今天下午在官网看了下相关的介绍。&lt;br&gt;
    
    </summary>
    
    
      <category term="Consul" scheme="http://yoursite.com/tags/Consul/"/>
    
  </entry>
  
</feed>
